#' multi_sims
#'
#' Generate artificial oscillating time series of various types.
#' @param type character indicating which type of time series are to be generated. Possible values are:
#' \itemize{
#'   \item ps: Phase-Shifted plain sinusoids.
#'   \item pst: Phase-Shifted plain sinusoids with linear trend over time.
#'   \item psd: Phase-Shifted and Damped sinusoids (chirp).
#'   \item na: Noisy Amplitude, plain sinusoids with Gaussian white noise.
#'   \item nad: Noisy Amplitude Damped, plain sinusoids with Gaussian white noise.
#'   \item edls: Exponential Decay Lag Shifted.
#' }
#' @param noises numerical vector giving levels of noise to generate the data. Do not pass 0 (no noise) as this is already generated by default.
#' The feature controlled by this argument varies across types of simulations.
#' \itemize{
#'   \item Phase-Shifted simulations ('psX'): standard deviation of the Gaussian distribution used to shift the curves.
#'   \item Noisy-Amplitude simulations ('naX'): standard deviation of the Gaussian distribution used to generate amplitude noise at each time point.
#'   \item Exponential decay Lag Shifted: standard deviation of the Gaussian distribution used to generate the lag between excitation time and response time.
#' }
#' Typical values ranges from 0 to 2.
#' @param n number of trajectories per noise level.
#' @param freq numeric, spacing between 2 time points.
#' @param end numeric, end time of simulations.
#' @param ... Additional arguments specific to simulation type. See corresponding sim_X functions.
#'
#' @note TODO - function is not optimized: it builds the simulation by growing a data.table.
#'
#' @seealso plot_sim, sim_phase_shifted, sim_phase_shifted_damped, sim_phase_shifted_with_fixed_trend, sim_noisy_amplitude, sim_noisy_amplitude_damped, sim_expodecay_lagged_stim
#' @return a data.table containing the trajectories in long format in 4 columns. "variable" indicates the ID of the trajectory at "noise" level.
#' @export
#'
#' @examples
#' x <- multi_sims(type = "ps", noises = seq(0.5, 2, 0.5), n = 10, freq = 0.5, end = 30)
#' plot_sim(x)
#'
multi_sims <- function(type, noises, n, freq = 0.2, end = 50, ...){
  # /!\ not optimized, growing data table
  # Generate multiple simulations of the indicated type.
  # noises: numeric vector with noise value, DO NOT PASS 0, as it is already used to initialize the output
  # ps: phase shifted
  # pst: phase shifted with linear trend
  # psd: phase shifted damped
  # na: noisy amplitude
  # nad: noisy amplitude damped
  # edls: expo decay lagged stimulation

  if(!(type %in% c("ps", "pst", "psd", "na", "nad", "edls"))){
    stop("type must be one of c('ps', 'pst', 'psd', 'na', 'nad', 'edls')")
  }
  if(length(type)>1){
    stop("Only one type of simulations can be generated at once. To generate a dataset with more than one type, call mulit_sims twice and bind the outputs.")
  }
  if(0 %in% noises) warning("Trajectories without noise are already generated by default.")

  # Initialize data.table with no noise
  if(type == "ps"){multi_sim <- sim_phase_shifted(noise = 0, n = n, freq = freq, end = end, ...)}
  else if(type == "pst"){multi_sim <- sim_phase_shifted_with_fixed_trend(noise = 0, n = n, freq = freq, end = end, ...)}
  else if(type == "psd"){multi_sim <- sim_phase_shifted_damped(noise = 0, n = n, freq = freq, end = end, ...)}
  else if(type == "na"){multi_sim <- sim_noisy_amplitude(noise = 0, n = n, freq = freq, end = end, ...)}
  else if(type == "nad"){multi_sim <- sim_noisy_amplitude_damped(noise = 0, n = n, freq = freq, end = end, ...)}
  else if(type == "edls"){multi_sim <- sim_expodecay_lagged_stim(noise = 0, n = n, freq = freq, end = end, ...)}

  multi_sim$noise <- 0
  for(noise in noises){
    if(type == "ps"){temp <- sim_phase_shifted(noise = noise, n = n, freq = freq, end = end, ...)}
    else if(type == "pst"){temp <- sim_phase_shifted_with_fixed_trend(noise = noise, n = n, freq = freq, end = end, ...)}
    else if(type == "psd"){temp <- sim_phase_shifted_damped(noise = noise, n = n, freq = freq, end = end, ...)}
    else if(type == "na"){temp <- sim_noisy_amplitude(noise = noise, n = n, freq = freq, end = end, ...)}
    else if(type == "nad"){temp <- sim_noisy_amplitude_damped(noise = noise, n = n, freq = freq, end = end, ...)}
    else if(type == "edls"){temp <- sim_expodecay_lagged_stim(noise = noise, n = n, freq = freq, end = end, ...)}
    temp$noise <- noise
    multi_sim <- rbind(multi_sim, temp)
  }
  return(multi_sim)
}


plot_sim <- function(data, x = "Time", y = "value", group = "variable", use.facet = T, facet = "noise", alpha = 0.2){
  require(ggplot2)
  p <- ggplot(data, aes_string(x = x, y = y)) + geom_line(aes_string(group = group), alpha = alpha)
  p <- p + stat_summary(fun.y=mean, geom="line", colour = "blue", size = 1.5)
  if(use.facet){
    p <- p + facet_grid(as.formula(paste(facet, "~ .")))
  }
  p
}


sim_phase_shifted <- function(n, noise, freq = 0.2, end = 50, return.wide = F){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # end: end time of simulations
  # return.wide: returns data in wide or long format

  require(data.table)
  # If sampling rate < 1, adjust end such that seq(from, to, by) re

  # Create a matrix of shifted times
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  shifts <- rnorm(n, 0, noise)
  shifts <- matrix(shifts, nrow = length(tvec), ncol = n, byrow = T)
  time_matrix <- time_matrix + shifts

  # Replace each shifted time by it sine function
  sins <- sin(time_matrix)

  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)
  }

  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_phase_shifted_damped <- function(n, noise, damp_params, freq = 0.2, end = 50){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # end: end time of simulations
  # damp_params: c(initial amplitude, dampen rate)

  require(data.table)

  # Create a matrix of shifted times
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  shifts <- rnorm(n, 0, noise)
  shifts <- matrix(shifts, nrow = length(tvec), ncol = n, byrow = T)
  time_matrix <- time_matrix + shifts

  # Replace each shifted time by it sine function
  sins <- sin(time_matrix) * damp_params[1] * exp(-damp_params[2]*time_matrix)

  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_phase_shifted_with_fixed_trend <- function(n, noise, slope, freq = 0.2, end = 50){
  # Add a trend, i.e. a linear increase or decrease, to simulations
  # See sim_phase_shifted for arguments. Slope indicates the slope of the trend (change of mean value per unit of time)

  sins <- sim_phase_shifted(n, noise, freq, end, return.wide = F)
  trend_vec <- unique(sins$Time)
  trend_vec <- trend_vec * slope
  sins[, value := value + trend_vec, by = .(variable)]
  return(sins)
}


sim_noisy_amplitude <- function(n, noise, freq = 0.2, end = 50, return.wide = F){
  # Create a matrix of times and noise
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  noise_matrix <- replicate(n, rnorm(length(tvec), 0, noise))

  # Replace each shifted time by it sine function and add white noise
  sins <- sin(time_matrix)
  sins <- sins + noise_matrix

  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)
  }

  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}

sim_noisy_amplitude_damped <- function(n, noise, damp_params, freq = 0.2, end = 50){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # end: end time of simulations
  # damp_params: c(initial amplitude, dampen rate)

  require(data.table)

  # Create a matrix of times and noise
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  noise_matrix <- replicate(n, rnorm(length(tvec), 0, noise))

  # Replace each shifted time by it sine function
  sins <- sin(time_matrix) * damp_params[1] * exp(-damp_params[2]*time_matrix)
  sins <- sins + noise_matrix

  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_expodecay_lagged_stim <- function(n, noise, interval.stim = 5, lambda = 0.2, freq = 0.2, end = 50, return.wide = F){
  # A fucntion to simulate a population of n trajectories of expo decay, that are taken up at regular time by stimulus.
  # The noise add a lag between the stimulus and the increase.
  # n: number of trajectories
  # noise: standard deviation for the lag
  # interval.stim: how long between each stimulation?
  # lambda: desintegration rate
  # freq: sampling rate (in time unit), how often do we compute the state of the system
  # end: end time of simulations
  # return.wide: returns data in wide or long format

  # Time vector
  tvec <- seq(0, end-1, by = freq)
  # Matrix with stimulation times
  stim_time <- seq(interval.stim, end-1 , interval.stim)
  stim_time_matrix <- matrix(stim_time, nrow = length(stim_time), ncol = n)

  # Randomize the stimulation times (represent random lag), forbid lag < 0
  noise_matrix <- abs(replicate(n, rnorm(n = length(stim_time), mean = 0, sd = noise)))
  stim_time_matrix <- stim_time_matrix + noise_matrix

  # Initialize trajectories with 0 everywhere, set to 1 at stimulus times
  trajs <- matrix(0, nrow = length(tvec), ncol = n)
  for(col in 1:ncol(stim_time_matrix)){
    for(row in 1:nrow(stim_time_matrix)){
      index <- which(tvec >= stim_time_matrix[row, col])[1]
      trajs[index, col] <- 1
    }
  }

  # Expo decay computed thanks to previous value
  decrease_factor <- exp(-lambda * freq)
  for(col in 1:ncol(trajs)){
    for(row in 2:nrow(trajs)){
      # If not at a stim time, decay
      if(trajs[row, col] != 1){trajs[row, col] <- trajs[row-1, col] * decrease_factor}
    }
  }

  # Go to data.table
  trajs <- as.data.table(trajs)
  trajs <- cbind(seq(0, end-1, by = freq), trajs)
  colnames(trajs)[1] <- "Time"
  if(return.wide){
    return(trajs)
  }

  # Format long data table
  trajs <- melt(trajs, id.vars = "Time")
  return(trajs)
}

