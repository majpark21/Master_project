#' mySpline
#'
#' Interpolate points of a trajectory by spline. Returns the interpolated points
#' along with the data in a single trajectory.
#' @param x,y vectors giving the coordinates of the points to be interpolated.
#' @param n interpolation takes place at n equally spaced points spanning the
#'   interval [xmin, xmax]
#'
#' @details Spline interpolation is made according to stats::spline. See doc for
#'   details and default.
#' @return A list containing components x and y which give the ordinates where
#'   interpolation took place and the interpolated values.
#' @export
#'
#' @examples
#' x <- sin(seq(0,5,0.75))
#' x_spline <- mySpline(seq_along(x), x, 3*length(x))
#' plot(seq_along(x), x)
#' plot(x_spline$x, x_spline$y, type = 'b')
#'
mySpline <- function(x, y, n) {
    fit <- spline(x, y, n)
    x2 <- c(x, fit$x)
    y2 <- c(y, fit$y)
    y2 <- y2[order(x2)]
    x2 <- x2[order(x2)]
    return(list(x = x2, y = y2))
}


#' rollex
#'
#' Extended rolling mean, fill the extremeties with linear extrapolation. This
#' way the output has same length as the original vector.
#' @param x a numerical vector
#' @param k integer, width of the window for rolling mean
#'
#' @return A numerical vector of same length as x.
#' @export
#'
#' @examples
#' # Sinusoid + Gaussian white noise
#' x <- sin(seq(0,30,0.05))
#' x <- x + rnorm(length(x), mean = 0, sd = 0.2)
#' x_rollex <- rollex(x, k = 3)
#' plot(x)
#' lines(x_rollex, col = 'blue', lwd = 2)
rollex <- function(x, k = 5) {
    require(zoo)
    roll <- rollmean(x, k, na.pad = T)
    NonNAindex <- which(!is.na(roll))
    fst <- min(NonNAindex)
    lst <- max(NonNAindex)

    # Left and Right slopes
    lslope <- (roll[fst + 1] - roll[fst])/2
    rslope <- (roll[lst] - roll[lst - 1])/2

    # Replace NAs generated by roll with approx
    for (i in 1:(fst - 1)) {
        roll[i] <- roll[fst] + lslope * (i - fst)
    }
    for (i in (lst + 1):length(roll)) {
        roll[i] <- roll[lst] + rslope * (i - lst)
    }
    return(roll)
}



#' detect.peak
#'
#' Detect peaks by identifying local maxima in a rolling window.
#' @param x numerical vector
#' @param window.size integer, width of rolling window.
#' @param what character indicating whether maxima or minima should be looked
#'   for. One of c('maxi', 'mini').
#'
#' @return A logical vector. TRUE indicates a local maxima/minima. NAs are
#'   padded at the extremeties to keep same length as x.
#' @export
#'
#' @examples
#' x <- sin(seq(0,25,0.1))
#' plot(x)
#' abline(v = which(detect.peak(x, 7, "maxi")), col = 'red', lty = 'dashed')
#' abline(v = which(detect.peak(x, 7, "mini")), col = 'blue', lty = 'dashed')
#'
detect.peak <- function(x, window.size, what = "maxi") {
    require(zoo)
    if (window.size%%2 == 0)
        stop("window size must be odd")
    if (!what %in% c("maxi", "mini", "both"))
        stop("what must be one of c('maxi', 'mini')")
    middle <- ceiling(window.size/2)
    if (what == "maxi") {
        out <- rollapply(x, window.size, function(x) which.max(x) == middle)
    } else if (what == "mini") {
        out <- rollapply(x, window.size, function(x) which.min(x) == middle)
    }
    out <- c(rep(NA, middle - 1), out, rep(NA, middle - 1))
    return(out)
}

