#' mySpline
#'
#' Interpolate points of a trajectory by spline. Returns the interpolated points
#' along with the data in a single trajectory.
#' @param x,y vectors giving the coordinates of the points to be interpolated.
#' @param n interpolation takes place at n equally spaced points spanning the
#'   interval [xmin, xmax]
#'
#' @details Spline interpolation is made according to stats::spline. See doc for
#'   details and default.
#' @return A list containing components x and y which give the ordinates where
#'   interpolation took place and the interpolated values.
#' @export
#'
#' @examples
#' x <- sin(seq(0,5,0.75))
#' x_spline <- mySpline(seq_along(x), x, 3*length(x))
#' plot(seq_along(x), x)
#' plot(x_spline$x, x_spline$y, type = "b")
#'
mySpline <- function(x, y, n){
  fit <- spline(x, y, n)
  x2 <- c(x, fit$x)
  y2 <- c(y, fit$y)
  y2 <- y2[order(x2)]
  x2 <- x2[order(x2)]
  return(list(x = x2, y = y2))
}


#' rollex
#'
#' Extended rolling mean, fill the extremeties with linear extrapolation. This way the output has same length as the original vector.
#' @param x a numerical vector
#' @param k integer, width of the window for rolling mean
#'
#' @return A numerical vector of same length as x.
#' @export
#'
#' @examples
#' # Sinusoid + Gaussian white noise
#' x <- sin(seq(0,30,0.05))
#' x <- x + rnorm(length(x), mean = 0, sd = 0.2)
#' x_rollex <- rollex(x, k = 3)
#' plot(x)
#' lines(x_rollex, col = "blue", lwd = 2)
rollex <- function(x, k = 5){
  require(zoo)
  roll <- rollmean(x, k, na.pad = T)
  NonNAindex <- which(!is.na(roll))
  fst <- min(NonNAindex)
  lst <- max(NonNAindex)

  # Left and Right slopes
  lslope <- (roll[fst + 1] - roll[fst]) / 2
  rslope <- (roll[lst] - roll[lst - 1]) / 2

  # Replace NAs generated by roll with approx
  for(i in 1:(fst-1)){
    roll[i] <- roll[fst] + lslope * (i - fst)
  }
  for(i in (lst+1):length(roll)){
    roll[i] <- roll[lst] + rslope * (i - lst)
  }
  return(roll)
}
