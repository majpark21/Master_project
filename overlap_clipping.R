# 1) Get moving average for each trajectory
# 2) Clip trajectory according to its positions compared to its own moving average (step function 0 or 1)
# 3) Within each condition compute overlap of clipped trajectories for each trajectory pair
# 4) Look at this distribution, skew towards large overlaps is a sign of synchronization

overlap_clipping <- function(data, condition, label, measure){
  # Compute overlap between all pairs of clipped trajectories in each condition
  
  # data: a data table containing CLIPPED trajectories
  # condition: column name that fully define an experimental condition; MUST BE INTEGERS OR CHARACTERS
  # measure: column name with clipped trajectories
  # label: column name with label of individual objects in each condition (cell label); LABELS MUST BE INTEGERS OR CHARACTERS
  
  if(!(class(data[,get(condition)]) %in% c("integer", "character"))){
    stop("Column 'condition' must be integer or character.")
  }
  if(!(class(data[,get(label)]) %in% c("integer", "character"))){
    stop("Column 'label' must be integer or character.")
  }
  
  require(data.table)
  setkeyv(data, c(condition, label))

  # Number of rows for data table initialization, sum of number of pairs in each condition
  nber_row <- 0
  for(i in unique(data[, get(condition)])){
    nber_row <- nber_row + choose(length(unique(data[.(i), get(label)])), 2)
  }
  
  # One row = one pair in one condition; set column types according to input types
  out <- data.table(matrix(ncol = 4, nrow = nber_row))
  colnames(out) <- c(condition, "Label1", "Label2", "Overlap")
  if(class(data[,get(condition)]) == "integer"){out[[condition]] <- as.integer(out[[condition]])}
  else if(class(data[,get(condition)]) == "character"){out[[condition]] <- as.character(out[[condition]])}
  
  if(class(data[,get(label)]) == "integer"){
    out[, Label1 := as.integer(Label1)]
    out[, Label2 := as.integer(Label2)]
  }
  else if(class(data[,get(label)]) == "character"){
    out[, Label1 := as.character(Label1)]
    out[, Label2 := as.character(Label2)]
  }

  out[, Overlap := as.numeric(Overlap)]
  
  curr_row <- 1L
  # Loop condition
  for(i in unique(data[, get(condition)])){
    labels <- unique(data[.(i), get(label)])
    # Loop 1st label
    for(j in 1:(length(labels)-1)){
      # Loop 2nd label
      for(k in (j+1):length(labels)){
        set(out, curr_row, 1L, i)
        set(out, curr_row, 2L, labels[j])
        set(out, curr_row, 3L, labels[k])
        set(out, curr_row, 4L, overlap(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)]))
        curr_row <- curr_row + 1L
      }
    }
  }
  return(out)
}


rollex <- function(x, k = 5){
  # Extended rolling mean, fill the extremeties with linear approximation
  require(zoo)
  roll <- rollmean(x, k, na.pad = T)
  NonNAindex <- which(!is.na(roll))
  fst <- min(NonNAindex)
  lst <- max(NonNAindex)
  
  # Left and Right slopes
  lslope <- (roll[fst + 1] - roll[fst]) / 2
  rslope <- (roll[lst] - roll[lst - 1]) / 2
  
  # Replace NAs generated by roll with approx
  for(i in 1:(fst-1)){
    roll[i] <- roll[fst] + lslope * (i - fst) 
  }
  for(i in (lst+1):length(roll)){
    roll[i] <- roll[lst] + rslope * (i - lst) 
  }
  return(roll)
}


clip <- function(x, y){
  # Take two numeric vectors of same length, set x to 1 when above y and x to 0 when below y
  return(ifelse(x >= y, 1, 0))
}


wrap_clip <- function(x, k = 5){
  return(clip(x, rollex(x, k)))
}


overlap <- function(x, y){
  # How often do 2 clipped time series have the same value?
  temp <- ifelse(x==y,1,0)
  return(sum(temp)/length(temp))
}


#####


library(data.table)
library(ggplot2)
Cora <- fread("C:/Users/pixel/Dropbox/Marc-Antoine/data/set1-Coralie/tCoursesSelected.csv")
Cora[, Ratio := objCyto_Intensity_MeanIntensity_imErkCorrOrig / objNuc_Intensity_MeanIntensity_imErkCorrOrig]
setkey(Cora, Image_Metadata_Site, objNuc_TrackObjects_Label)

ClipRatio <- Cora[, .(clip_ratio = wrap_clip(Ratio, k = 5)), by = .(Image_Metadata_Site, objNuc_TrackObjects_Label)]
Overlap <- overlap_clipping(data = ClipRatio, condition = "Image_Metadata_Site", label = "objNuc_TrackObjects_Label", measure = "clip_ratio")

##### 
#Plot example of a trajectory, rolling mean and clipped trajectory
#plot(ClipRatio[Image_Metadata_Site==5 & objNuc_TrackObjects_Label==2, clip_ratio], type = 'l', col = 'blue')
#points(Cora[Image_Metadata_Site == 5 & objNuc_TrackObjects_Label == 2, Ratio])
#lines(Cora[Image_Metadata_Site == 5 & objNuc_TrackObjects_Label == 2, Ratio])
#lines(rollex(Cora[Image_Metadata_Site == 5 & objNuc_TrackObjects_Label == 2, Ratio]), col = 'red')

#ClipRatio$RealTime <- Cora$RealTime
#p <- ggplot(ClipRatio[.(7,2)], aes(x=RealTime, y=clip_ratio)) + geom_step(alpha = 1) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()); p
#####


overlap(ClipRatio[.(7,1), clip_ratio], ClipRatio[.(7,42), clip_ratio])
cor(ClipRatio[.(7,3), clip_ratio],ClipRatio[.(7,42), clip_ratio], method = "k")



p <- ggplot(Overlap, aes(x = Image_Metadata_Site, y = Overlap)) + geom_boxplot(aes(group  = Image_Metadata_Site))
p


temp <- overlap_clipping(data = ClipRatio, condition = "Image_Metadata_Site", label = "objNuc_TrackObjects_Label", measure = "clip_ratio")
