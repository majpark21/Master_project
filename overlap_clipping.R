rollex <- function(x, k = 5){
  # Extended rolling mean, fill the extremeties with linear approximation
  require(zoo)
  roll <- rollmean(x, k, na.pad = T)
  NonNAindex <- which(!is.na(roll))
  fst <- min(NonNAindex)
  lst <- max(NonNAindex)
  
  # Left and Right slopes
  lslope <- (roll[fst + 1] - roll[fst]) / 2
  rslope <- (roll[lst] - roll[lst - 1]) / 2
  
  # Replace NAs generated by roll with approx
  for(i in 1:(fst-1)){
    roll[i] <- roll[fst] + lslope * (i - fst) 
  }
  for(i in (lst+1):length(roll)){
    roll[i] <- roll[lst] + rslope * (i - lst) 
  }
  return(roll)
}


clip <- function(x, y){
  # Take two numeric vectors of same length, set x to 1 when above y and x to 0 when below y
  return(ifelse(x >= y, 1, 0))
}


wrap_clip <- function(x, k = 5){
  return(clip(x, rollex(x, k)))
}


overlap <- function(x, y){
  # How often do 2 clipped time series have the same value?
  temp <- ifelse(x==y,1,0)
  return(sum(temp)/length(temp))
}


library(zoo)
library(data.table)
library(ggplot2)
Cora <- fread("C:/Users/pixel/Dropbox/Marc-Antoine/data/set1-Coralie/tCoursesSelected.csv")
Cora[, Ratio := objCyto_Intensity_MeanIntensity_imErkCorrOrig / objNuc_Intensity_MeanIntensity_imErkCorrOrig]
setkey(Cora, Image_Metadata_Site, objNuc_TrackObjects_Label)

ClipRatio <- Cora[, .(clip_ratio = wrap_clip(Ratio)), by = .(Image_Metadata_Site, objNuc_TrackObjects_Label)]
ClipRatio$RealTime <- Cora$RealTime

##### 
#Plot example of a trajectory, rolling mean and clipped trajectory
#plot(ClipRatio[Image_Metadata_Site==5 & objNuc_TrackObjects_Label==2, clip_ratio], type = 'l', col = 'blue')
#points(Cora[Image_Metadata_Site == 5 & objNuc_TrackObjects_Label == 2, Ratio])
#lines(Cora[Image_Metadata_Site == 5 & objNuc_TrackObjects_Label == 2, Ratio])
#lines(rollex(Cora[Image_Metadata_Site == 5 & objNuc_TrackObjects_Label == 2, Ratio]), col = 'red')

#p <- ggplot(ClipRatio[.(7,2)], aes(x=RealTime, y=clip_ratio)) + geom_step(alpha = 1) + theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()); p
#####


overlap(ClipRatio[.(7,1), clip_ratio], ClipRatio[.(7,42), clip_ratio])
cor(ClipRatio[.(7,3), clip_ratio],ClipRatio[.(7,42), clip_ratio], method = "k")


# Compute overlap between all pairs of clipped trajectories in each condition
nber_row <- 0
for(i in 0:7){
  nber_row <- nber_row + choose(length(unique(ClipRatio[.(i), objNuc_TrackObjects_Label])), 2)
}

# One row = one pair in one condition; set column types
Overlap <- data.table(matrix(ncol = 4, nrow = nber_row))
colnames(Overlap) <- c("Image_Metadata_Site", "Label1", "Label2", "Overlap")
Overlap <- Overlap[, lapply(.SD, as.integer)]
Overlap[, Overlap := as.numeric(Overlap)]

curr_row <- 1L
# Loop condition
for(i in 0:7){
  labels <- unique(ClipRatio[.(i), objNuc_TrackObjects_Label])
  # Loop 1st label
  for(j in 1:(length(labels)-1)){
    # Loop 2nd label
    for(k in (j+1):length(labels)){
      set(Overlap, curr_row, 1L, i)
      set(Overlap, curr_row, 2L, labels[j])
      set(Overlap, curr_row, 3L, labels[k])
      set(Overlap, curr_row, 4L, overlap(ClipRatio[.(i, labels[j]), clip_ratio], ClipRatio[.(i, labels[k]), clip_ratio]))
      curr_row <- curr_row + 1L
    }
  }
}


p <- ggplot(Overlap, aes(x = Image_Metadata_Site, y = Overlap)) + geom_boxplot(aes(group  = Image_Metadata_Site))
p
