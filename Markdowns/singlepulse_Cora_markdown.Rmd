---
title: "Cora dataset single pulse"
author: "Jacques Marc-Antoine"
date: "14 septembre 2017"
output: 
  html_document:
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Experiment and Aim

The experiment is a dose response matrix, which measures ERK activity as a function of duration and intensity of light stimulus.

For convenience we define the following code to represent the treatment conditions: “PXX-IYY”; where X represents the duration of the pulse and I its intensity.

The main goal here is simply to fit exponential decay and/or to extract features from these simple trajectories (single peak).

One condition, P0.1-I0, was forgotten when the experiment was run, we introduce artificial data to replace it. Data are normalized in a fold-change per trajectory fashion, basal time span is defined right before the stimulus, which was performed at time 10.

```{r}
source("../rscripts/package.R")
rm(Cora)
source("../rscripts/merge_load_singlepulse_data.R")
```

```{r cache=T, fig.width=21, fig.height=12}
ggplot(Cora, aes(x= RealTime, y=Ratio.norm)) + geom_line(aes(group=Label), alpha=0.4) + facet_wrap("Condition", nrow = 5) + stat_summary(fun.y = mean, geom = "line", col = "red", lwd=1.75) + theme(text = element_text(size= 25)) + ggtitle("Per-trajectory normalized, fold change based on time [0, 9]")
```

As we will be interested only in fitting the peaks, we cut the data between time 10 and 25:
```{r}
Cora <- Cora[RealTime >= 10 & RealTime <= 25]
```

```{r cache=T, fig.width=21, fig.height=12}
ggplot(Cora, aes(x= RealTime, y=Ratio.norm)) + geom_line(aes(group=Label), alpha=0.4) + facet_wrap("Condition", nrow = 5) + stat_summary(fun.y = mean, geom = "line", col = "red", lwd=1.75) + theme(text = element_text(size= 25)) + ggtitle("Per-trajectory normalized, fold change based on time [0, 9]")
```

Finally, when estimating the parameters, it will be useful to have a baseline at 0 and not 1, so we shift all the curves by 1, and clip negative values to 0:
```{r}
Cora[, Ratio.norm := Ratio.norm - 1]
Cora[Ratio.norm < 0, Ratio.norm := 0]
```

```{r cache=T, fig.width=21, fig.height=12}
ggplot(Cora, aes(x= RealTime, y=Ratio.norm)) + geom_line(aes(group=Label), alpha=0.4) + facet_wrap("Condition", nrow = 5) + stat_summary(fun.y = mean, geom = "line", col = "red", lwd=1.75) + theme(text = element_text(size= 25)) + ggtitle("Per-trajectory normalized, fold change based on time [0, 9]")
```

# Maximum peak

```{r}
max.peak.Cora <- Cora[, .(max = max(Ratio.norm), time.max = RealTime[which.max(Ratio.norm)]), by = c("Condition", "Label")]
max.peak.Cora[, pulse.length := str_extract(max.peak.Cora$Condition, "[0-9]+(\\.[0-9]+)?")]
```

```{r fig.width=15, fig.height=10}
ggplot(max.peak.Cora, aes(x=Condition, y=time.max)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Time at which peak reaches its maximum")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```

This time is fairly robust in every condition.

```{r fig.width=15, fig.height=10}
ggplot(max.peak.Cora, aes(x=Condition, y=max)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Maximum peak (fold change)")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```

Increase with light intensity for short pulse P0.05 and P1; stable for the others whatever the light intensity.

# Full width at half maximum

## Spline interpolation

As the number of sampled point is relatively low, especially in ascending phase, we determine the time at which ERk reaches half of its maximal activity by first fitting a spline:

```{r}
y <- Cora[.("P5-I100","11_9"), Ratio.norm]
x <- Cora[.("P5-I100","11_9"), RealTime]
fit <- spline(x, y, 3*length(x))

plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
```

Black dots represents the data, red crosses the interpolated points. Oscillation occurs before the increase, but is dampened during the increasing and decreasing phase, which are of interest here.

### Get FWHM with minimal deviation from the half maximum value

```{r}
get.FWHM <- function(x, y, n = 10*length(x)){
  maxi <- max(y)
  tmaxi <- x[which.max(y)]
  
  fit <- spline(x, y, n)
  
  left <- fit$x[which.min(abs(fit$y[fit$x < tmaxi] - (maxi/2)))]
  right <- fit$x[which.max(which(fit$x <= tmaxi)) + which.min(abs(fit$y[fit$x > tmaxi] - (maxi/2)))]
  return(list(fwhm = right - left, left = left, right = right))
}
```

With previous example:
```{r}
fit <- spline(x, y, 2*length(x))
fwhm <- get.FWHM(x, y, n = 2*length(x))

plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm$fwhm,4))
```

If we increase the number of points for spline interpolation:
```{r}
fit <- spline(x, y, 30*length(x))
fwhm <- get.FWHM(x, y, n = 30*length(x))

plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm$fwhm,4))
```

On another curver:
```{r}
y <- Cora[.("P0.05-I25","6_1"), Ratio.norm]
x <- Cora[.("P0.05-I25","6_1"), RealTime]
```

```{r echo =F}
fit <- spline(x, y, 3*length(x))
fwhm <- get.FWHM(x, y, n = 3*length(x))
plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 17, y = 0.15, labels = round(fwhm$fwhm,4))
```

Wrong peak is returned, this shows some instability in the method since with more points:
```{r echo =F}
fit <- spline(x, y, 30*length(x))
fwhm <- get.FWHM(x, y, n = 30*length(x))
plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 17, y = 0.15, labels = round(fwhm$fwhm,4))
```


Pitfalls of the method are captured here:
```{r}
y <- Cora[.("P0.05-I0","0_7"), Ratio.norm]
x <- Cora[.("P0.05-I0","0_7"), RealTime]
```

```{r echo =F}
fit <- spline(x, y, 3*length(x))
fwhm <- get.FWHM(x, y, n = 3*length(x))
plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 19.5, y = 0.035, labels = round(fwhm$fwhm,4))
```

Left vertical dashed line shows that multiple peaks can lead to selection of the wrong time. Right vertical dashed line shows that even if the signal never actually crosses half value of the maximum again, a value will still be returned.

### Get FWHM by walking through the interpolated values

Another method is to sequentially walk through the interpolated points and to check everytime if the value is above or below half of the maximum. The starting point of this walk is situated at the time where the signal is at its maximum. One walk goes to the left, another one goes to the right.

This method enables to solve the multi-peak as well as the non-crossing problems highlighted in the previous section.

We redefine the function and add 
```{r}
get.FWHM <- function(x, y, n = 10*length(x), method = "walk"){
  if(!method %in% c("walk", "minimum")) stop("Method must be one of c('walk','minimum')")
  if(method == "walk"){
    
  } else if(method == "minimum"){
    maxi <- max(y)
    tmaxi <- x[which.max(y)]
    fit <- spline(x, y, n)
    left <- fit$x[which.min(abs(fit$y[fit$x < tmaxi] - (maxi/2)))]
    right <- fit$x[which.max(which(fit$x <= tmaxi)) + which.min(abs(fit$y[fit$x > tmaxi] - (maxi/2)))]
    return(list(fwhm = right - left, left = left, right = right))
  }
}
```




## Results

```{r}
fwhm.Cora <- Cora[, .(fwhm = )]
```




# Decay rate and Half-life time

## The exponential decay model

* The exponential decay model:

$\frac{dN}{dt} = -\lambda t$

which can be anatycally solved:

$N(t) =  N_0 \cdot e^{-\lambda t}$ 

* It can be linearized by applying a log: 

$log(N(t)) = log(N_0) - \lambda t$

This linearization means that we can fit the model with a simple linear regression, where the decay constant $\lambda$ becomes the slope.

* Half-Life

$T_{1/2} = \frac{ln2}{\lambda}$

## With linear transformation


## Non-linear fitting


# Growth rate 

## Linear regression


