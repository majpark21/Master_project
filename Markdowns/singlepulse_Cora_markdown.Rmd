---
title: "Cora dataset single pulse"
author: "Jacques Marc-Antoine"
date: "14 septembre 2017"
output: 
  html_document:
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Experiment and Aim

The experiment is a dose response matrix, which measures ERK activity as a function of duration and intensity of light stimulus.

For convenience we define the following code to represent the treatment conditions: “PXX-IYY”; where X represents the duration of the pulse and I its intensity.

The main goal here is simply to fit exponential decay and/or to extract features from these simple trajectories (single peak).

One condition, P0.1-I0, was forgotten when the experiment was run, we introduce artificial data to replace it. Data are normalized in a fold-change per trajectory fashion, basal time span is defined right before the stimulus, which was performed at time 10.

```{r}
source("../rscripts/package.R")
rm(Cora)
source("../rscripts/merge_load_singlepulse_data.R")
```

```{r cache=T, fig.width=21, fig.height=12}
ggplot(Cora, aes(x= RealTime, y=Ratio.norm)) + geom_line(aes(group=Label), alpha=0.4) + facet_wrap("Condition", nrow = 5) + stat_summary(fun.y = mean, geom = "line", col = "red", lwd=1.75) + theme(text = element_text(size= 25)) + ggtitle("Per-trajectory normalized, fold change based on time [0, 9]")
```

As we will be interested only in fitting the peaks, we cut the data between time 10 and 25:
```{r}
Cora.cp <- copy(Cora) # copy that will be used to keep full data
Cora <- Cora[RealTime >= 10 & RealTime <= 25] 
```

```{r cache=T, fig.width=21, fig.height=12}
ggplot(Cora, aes(x= RealTime, y=Ratio.norm)) + geom_line(aes(group=Label), alpha=0.4) + facet_wrap("Condition", nrow = 5) + stat_summary(fun.y = mean, geom = "line", col = "red", lwd=1.75) + theme(text = element_text(size= 25)) + ggtitle("Per-trajectory normalized, fold change based on time [0, 9]")
```

Finally, when estimating the parameters, it will be useful to have a baseline at 0 and not 1, so we shift all the curves by 1, and clip negative values to 0:
```{r}
Cora[, Ratio.norm := Ratio.norm - 1]
Cora[Ratio.norm < 0, Ratio.norm := 0]
```

```{r cache=T, fig.width=21, fig.height=12}
ggplot(Cora, aes(x= RealTime, y=Ratio.norm)) + geom_line(aes(group=Label), alpha=0.4) + facet_wrap("Condition", nrow = 5) + stat_summary(fun.y = mean, geom = "line", col = "red", lwd=1.75) + theme(text = element_text(size= 25)) + ggtitle("Per-trajectory normalized, fold change based on time [0, 9]")
```

# Maximum peak

```{r}
max.peak.Cora <- Cora[, .(max = max(Ratio.norm), time.max = RealTime[which.max(Ratio.norm)]), by = c("Condition", "Label")]
max.peak.Cora[, pulse.length := str_extract(max.peak.Cora$Condition, "[0-9]+(\\.[0-9]+)?")]
```

```{r fig.width=15, fig.height=10}
ggplot(max.peak.Cora, aes(x=Condition, y=time.max)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Time at which peak reaches its maximum")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```

This time is fairly robust in every condition.

```{r fig.width=15, fig.height=10}
ggplot(max.peak.Cora, aes(x=Condition, y=max)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Maximum peak (fold change)")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```

Increase with light intensity for short pulse P0.05 and P1; stable for the others whatever the light intensity.

# Full width at half maximum

## Spline interpolation

As the number of sampled point is relatively low, especially in ascending phase, we determine the time at which ERk reaches half of its maximal activity by first fitting a spline:

```{r}
y <- Cora[.("P5-I100","11_9"), Ratio.norm]
x <- Cora[.("P5-I100","11_9"), RealTime]
fit <- spline(x, y, 3*length(x))

plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
```

Black dots represents the data, red crosses the interpolated points. Oscillation occurs before the increase, but is dampened during the increasing and decreasing phase, which are of interest here.

### Get FWHM with minimal deviation from the half maximum value

```{r}
get.FWHM <- function(x, y, n = 10*length(x)){
  maxi <- max(y)
  tmaxi <- x[which.max(y)]
  
  fit <- spline(x, y, n)
  
  left <- fit$x[which.min(abs(fit$y[fit$x < tmaxi] - (maxi/2)))]
  right <- fit$x[which.max(which(fit$x <= tmaxi)) + which.min(abs(fit$y[fit$x > tmaxi] - (maxi/2)))]
  return(list(fwhm = right - left, left = left, right = right))
}
```

With previous example:
```{r}
fit <- spline(x, y, 2*length(x))
fwhm <- get.FWHM(x, y, n = 2*length(x))

plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm$fwhm,4))
```

If we increase the number of points for spline interpolation:
```{r}
fit <- spline(x, y, 30*length(x))
fwhm <- get.FWHM(x, y, n = 30*length(x))

plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm$fwhm,4))
```

On another curver:
```{r}
y <- Cora[.("P0.05-I25","6_1"), Ratio.norm]
x <- Cora[.("P0.05-I25","6_1"), RealTime]
```

```{r echo =F}
fit <- spline(x, y, 3*length(x))
fwhm <- get.FWHM(x, y, n = 3*length(x))
plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 17, y = 0.15, labels = round(fwhm$fwhm,4))
```

Wrong peak is returned, this shows some instability in the method since with more points we get the right value:
```{r echo =F}
fit <- spline(x, y, 30*length(x))
fwhm <- get.FWHM(x, y, n = 30*length(x))
plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 17, y = 0.15, labels = round(fwhm$fwhm,4))
```


Pitfalls of the method are captured here:
```{r}
y <- Cora[.("P0.05-I0","0_7"), Ratio.norm]
x <- Cora[.("P0.05-I0","0_7"), RealTime]
```

```{r echo =F}
fit <- spline(x, y, 3*length(x))
fwhm <- get.FWHM(x, y, n = 3*length(x))
plot(x, y, pch = 20, cex = 2)
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm$left, fwhm$right), lty = "dashed", col = "darkgreen")
text(x = 19.5, y = 0.035, labels = round(fwhm$fwhm,4))
```

Left vertical dashed line shows that multiple peaks can lead to selection of the wrong time. Right vertical dashed line shows that even if the signal never actually crosses half value of the maximum again, a value will still be returned.

### Get FWHM by walking through the interpolated values

Another method is to sequentially walk through the interpolated points and to check everytime if the value is above or below half of the maximum. The starting point of this walk is situated at the time where the signal is at its maximum. One walk goes to the left, another one goes to the right.

This method enables to solve the multi-peak as well as the non-crossing problems highlighted in the previous section.


First we define a spline function which returns both the interpolated points and the data in a single trajectory:
```{r}
mySpline <- function(x, y , n){
  fit <- spline(x, y, n)
  x2 <- c(x, fit$x)
  y2 <- c(y, fit$y)
  y2 <- y2[order(x2)]
  x2 <- x2[order(x2)]
  return(list(x = x2, y = y2))
}
```

We redefine the function with this new spline function, add a method argument. Method "minimum" corresponds to the previous implementation:
```{r}
get.FWHM <- function(x, y, n = 30*length(x), method = "walk"){
  if(!method %in% c("walk", "minimum")) stop("Method must be one of c('walk','minimum')")
  
  # Do NOT use interpolated data as maximum estimation
  maxi <- max(y)
  tmaxi <- x[which.max(y)]
  # Spline interpolated and data
  fit <- mySpline(x, y, n)
  
  if(method == "walk"){
    thresh <- maxi/2
    start <- which(fit$x == tmaxi)[1]
    # Right walk
    right <- NA
    for(i in start:length(fit$x)){
      if(fit$y[i] < thresh){
        # Once threshold is passed, choose the value between i and i-1 that is the closest to it
        right <- ifelse(abs(thresh - fit$y[i-1]) < abs(thresh - fit$y[i]), fit$x[i-1], fit$x[i])
        break
      }
    }
    # Left walk
    left <- NA
    for(i in seq(start, 1, -1)){
      if(fit$y[i] < thresh){
        left <- ifelse(abs(thresh - fit$y[i+1]) < abs(thresh - fit$y[i]), fit$x[i+1], fit$x[i])
        break
      }
    }
    
  } else if(method == "minimum"){
    left <- fit$x[which.min(abs(fit$y[fit$x < tmaxi] - (maxi/2)))]
    right <- fit$x[which.max(which(fit$x <= tmaxi)) + which.min(abs(fit$y[fit$x > tmaxi] - (maxi/2)))]
  }
  
  return(list(fwhm = right - left, left = left, right = right))
}
```

On the previous example with the new method:
```{r}
y <- Cora[.("P5-I100","11_9"), Ratio.norm]
x <- Cora[.("P5-I100","11_9"), RealTime]
fit <- mySpline(x, y, 2*length(x))
fwhm.mini <- get.FWHM(x, y, n = 2*length(x), method = "minimum")
fwhm.walk <- get.FWHM(x, y, n = 2*length(x), method = "walk")

par(mfrow= c(1,2))
plot(x, y, pch = 20, cex = 2, main = "Minimum method")
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm.mini$left, fwhm.mini$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm.mini$fwhm,4))

plot(x, y, pch = 20, cex = 2, main = "Walk method")
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm.walk$left, fwhm.walk$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm.walk$fwhm,4))
```

Identical result. Let's move to the problematic cases:
```{r}
y <- Cora[.("P0.05-I25","6_1"), Ratio.norm]
x <- Cora[.("P0.05-I25","6_1"), RealTime]
```

```{r echo = FALSE}
fit <- mySpline(x, y, 2*length(x))
fwhm.mini <- get.FWHM(x, y, n = 3*length(x), method = "minimum")
fwhm.walk <- get.FWHM(x, y, n = 3*length(x), method = "walk")

par(mfrow= c(1,2))
plot(x, y, pch = 20, cex = 2, main = "Minimum method")
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm.mini$left, fwhm.mini$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm.mini$fwhm,4))

plot(x, y, pch = 20, cex = 2, main = "Walk method")
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm.walk$left, fwhm.walk$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.2, labels = round(fwhm.walk$fwhm,4))
```

```{r}
y <- Cora[.("P0.05-I0","0_7"), Ratio.norm]
x <- Cora[.("P0.05-I0","0_7"), RealTime]
```

```{r echo = FALSE}
fit <- mySpline(x, y, 2*length(x))
fwhm.mini <- get.FWHM(x, y, n = 3*length(x), method = "minimum")
fwhm.walk <- get.FWHM(x, y, n = 3*length(x), method = "walk")

par(mfrow= c(1,2))
plot(x, y, pch = 20, cex = 2, main = "Minimum method")
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm.mini$left, fwhm.mini$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.02, labels = round(fwhm.mini$fwhm,4))

plot(x, y, pch = 20, cex = 2, main = "Walk method")
lines(fit, col = 'red', lty = "dashed")
points(fit, col = 'red', pch = 3)
abline(h = max(y)/2, lty = "dotted", col = "blue")
abline(v = c(fwhm.walk$left, fwhm.walk$right), lty = "dashed", col = "darkgreen")
text(x = 16, y = 0.02, labels = round(fwhm.walk$fwhm,4))
```

The walk method correctly identifies the left border and does not return a right border since the curve never crosses the half maximum-value anymore.

## Results

```{r}
fwhm.Cora <- Cora[, .(fwhm = as.numeric(get.FWHM(x=RealTime, y=Ratio.norm)$fwhm)), by = c("Condition", "Label")]
```

```{r, fig.width=15, fig.height=10}
fwhm.Cora[, pulse.length := str_extract(Condition, "[0-9]+(\\.[0-9]+)?")]
ggplot(fwhm.Cora, aes(x=Condition, y=fwhm)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("FWHM estimated by walk")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```

# Peakedness

Easy and natural measure is simply the ratio of maximum of peak divided by FWHM.
```{r}
peaked.Cora <- merge(fwhm.Cora, max.peak.Cora, by = c("Condition", "Label", "pulse.length"))
peaked.Cora[, peakedness := max / fwhm]
```

```{r fig.width=15, fig.height=10}
ggplot(peaked.Cora, aes(x=Condition, y=peakedness)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Peakedness: max / FWHM")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```


# Decay rate

We will isolate the descending part of the signal, which is simply defined at times after maxima was reached. In addition, values at zero are slightly shifted to positive values to avoid error when applying logarithm.
```{r}
desc.Cora <- merge(Cora, max.peak.Cora[,c("Condition", "Label", "max", "time.max")], by = c("Condition", "Label"))
desc.Cora <- desc.Cora[RealTime >= time.max]
desc.Cora[, time.after.max := seq_along(Ratio.norm)-1, by = c("Condition", "Label")]

desc.Cora[Ratio.norm==0, Ratio.norm := Ratio.norm + 0.01]
desc.Cora[max==0, max:= max + 0.01]
```

## Modelling with an exponential decay after peak maximum

### The exponential decay model

* The exponential decay model:

$\frac{dN}{dt} = -\lambda t$

which can be anatycally solved:

$N(t) =  N_0 \cdot e^{-\lambda t}$ 

* It can be linearized by applying a log: 

$log(N(t)) = log(N_0) - \lambda t$

This linearization means that we can fit the model with a simple linear regression, where the decay constant $\lambda$ becomes the slope.

* Half-Life

$T_{1/2} = \frac{ln2}{\lambda}$


### Results

We first subtract the intercept (i.e. log(max_value)), then fit a linear model without intercept and extract the slope which gives us the decay rate $\lambda$.

```{r}
desc.Cora[, log.Ratio := log(Ratio.norm) - log(max)]
decay.Cora <- desc.Cora[, .(slope = coef(lm(log.Ratio ~ time.after.max + 0))[1]), by = c("Condition", "Label")]
```

On one example:
```{r}
y <- Cora[.("P5-I100","11_9"), Ratio.norm]
# Shift to prevent error when log
y[which(y==0)] <- y[which(y==0)] + 0.01
# Descending phase (max is in position 5)
y.desc <- y[5:length(y)]
# Linearize by log, remove the max value
y.log <- log(y.desc) - log(y.desc[1])

par(mfrow=c(1,3))
plot(y, type = "b", main = "Whole trajectory")
plot(y.desc, type = "b", main = "Descending phase")
abline(lm(y.desc ~ seq_along(y.desc)), col = "blue", lty = "dashed")
plot(y.log, type = "b", main = "Log descending")
abline(lm(y.log ~ seq_along(y.log) + 0), col = "blue", lty = "dashed")
```

We see that the fit quality is quite poor and that directly fitting a linear model to the data could be even more appropriate. Though we've applied some clipping to negative normalized values in the beginning, what would happen without having them clipped?

```{r}
Cora2 <- copy(Cora.cp)
Cora2 <- myNorm(in.dt = Cora2, in.meas.col = "Ratio", in.rt.min = 0, in.rt.max = 10, in.by.cols = c("Condition", "Label"), in.type = "fold.change")
Cora2 <- Cora2[RealTime >= 10 & RealTime <= 25]
```

```{r echo = F}
y <- Cora2[.("P5-I100","11_9"), Ratio.norm]
# Shift to prevent error when log
y[which(y==0)] <- y[which(y==0)] + 0.01
# Descending phase (max is in position 5)
y.desc <- y[5:length(y)]
# Linearize by log, remove the max value
y.log <- log(y.desc) - log(y.desc[1])

par(mfrow=c(1,3))
plot(y, type = "b", main = "Whole trajectory")
plot(y.desc, type = "b", main = "Descending phase")
abline(lm(y.desc ~ seq_along(y.desc)), col = "blue", lty = "dashed")
plot(y.log, type = "b", main = "Log descending")
abline(lm(y.log ~ seq_along(y.log) + 0), col = "blue", lty = "dashed")
```

Slightly better, what happens if we don't cut the tail of the decay?

```{r}
Cora2 <- copy(Cora.cp)
Cora2 <- myNorm(in.dt = Cora2, in.meas.col = "Ratio", in.rt.min = 0, in.rt.max = 10, in.by.cols = c("Condition", "Label"), in.type = "fold.change")
Cora2 <- Cora2[RealTime >= 10]
```

```{r echo = F}
y <- Cora2[.("P5-I100","11_9"), Ratio.norm]
# Shift to prevent error when log
y[which(y==0)] <- y[which(y==0)] + 0.01
# Descending phase (max is in position 5)
y.desc <- y[5:length(y)]
# Linearize by log, remove the max value
y.log <- log(y.desc) - log(y.desc[1])

par(mfrow=c(1,3))
plot(y, type = "b", main = "Whole trajectory")
plot(y.desc, type = "b", main = "Descending phase")
abline(lm(y.desc ~ seq_along(y.desc)), col = "blue", lty = "dashed")
plot(y.log, type = "b", main = "Log descending")
abline(lm(y.log ~ seq_along(y.log) + 0), col = "blue", lty = "dashed")
```

No real improvement, let's keep the regression on clipped and trimmed data.

```{r fig.width=15, fig.height=10}
decay.Cora[, pulse.length := str_extract(Condition, "[0-9]+(\\.[0-9]+)?")]
ggplot(decay.Cora, aes(x=Condition, y=slope)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Decay rate estimated by exponential decay linear fitting")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x") + scale_y_continuous(limits = c(-0.75,0.3))
```

This behaves like the peakedness distribution though the relevance of the exponential decay is doubtful. In addition the distribution look very skewed, overall the method do not appear very reliable. Flat profiles at P0.05-I0 and P0.05-I5 have clearly negative slopes, what is far from what we see by looking at the curves.

A reason could be that the peaks are usually plateauing before dropping, therefore the exponential model is probably not adapted.

## Linear fitting between peak max and half-max

We could try to simply get a couple of points after the peak maximum and fit a line on this. How to define this couple or points? Since the peaks tend to plateau, we will use the points between the maximum of the peak and the time at which it reaches half of its maximum. Note that we also force the regression to use the maximum of the peak as intercept.

```{r}
right.fwhm.Cora <- Cora[, .(right = as.numeric(get.FWHM(x=RealTime, y=Ratio.norm)$right)), by = c("Condition", "Label")]
desc.Cora <- merge(Cora, right.fwhm.Cora)
desc.Cora <- merge(desc.Cora, max.peak.Cora)
desc.Cora <- desc.Cora[RealTime >= time.max & RealTime <= right]
desc.Cora[, time.after.max := seq_along(Ratio.norm)-1, by = c("Condition", "Label")]
desc.Cora[, Ratio.norm := Ratio.norm - max]

decay.Cora <- desc.Cora[, .(slope = coef(lm(Ratio.norm ~ time.after.max + 0))[1]), by = c("Condition", "Label")]
```

```{r fig.width=15, fig.height=10}
decay.Cora[, pulse.length := str_extract(Condition, "[0-9]+(\\.[0-9]+)?")]
ggplot(decay.Cora, aes(x=Condition, y=slope)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Decay rate estimated by linear fitting between maximum and half-maximum")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x") + scale_y_continuous(limits = c(-0.35,0.025))
```

Results appear more reliable: the dispersion is smaller, the distributions more centered, some distributions with ambiguous profile and not taken in account since not right border can be find for them. Flat profiles at P0.05-I0 and P0.05-I5 have a nearly 0 slope.

This approach should be favored over the exponential fitting.

# Growth rate 

## Linear fitting from 2min after stimulus to peak maximum

We will isolate the ascending part of the signal, which is simply defined at times before maxima was reached and 2 data point (i.e. 2min) after stimulation (usually 1 point after stimulation, signal tends to decrease).

```{r}
asc.Cora <- merge(Cora, max.peak.Cora[,c("Condition", "Label", "max", "time.max")], by = c("Condition", "Label"))
asc.Cora <- asc.Cora[RealTime <= time.max & RealTime >= 12]
```

```{r}
growth.Cora <- asc.Cora[, .(slope = coef(lm(Ratio.norm ~ RealTime + 0))[1]), by = c("Condition", "Label")]
```

On one example:
```{r}
y <- Cora[.("P5-I100","11_9"), Ratio.norm]
# Ascending phase (max is in position 5)
y.asc <- y[3:5]

par(mfrow=c(1,2))
plot(y, type = "b", main = "Whole trajectory")
plot(y.asc, type = "b", main = "Ascending phase")
abline(lm(y.asc ~ seq_along(y.asc)), col = "blue", lty = "dashed")
```

```{r fig.width=15, fig.height=10}
growth.Cora[, pulse.length := str_extract(Condition, "[0-9]+(\\.[0-9]+)?")]
ggplot(growth.Cora, aes(x=Condition, y=slope)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Growth rate estimated by linear fitting between 2min after stimulus and peak maximum")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```

## Linear fitting from half maximum to maximum

```{r}
left.fwhm.Cora <- Cora[, .(left = as.numeric(get.FWHM(x=RealTime, y=Ratio.norm)$left)), by = c("Condition", "Label")]
asc.Cora <- merge(Cora, left.fwhm.Cora)
asc.Cora <- merge(asc.Cora, max.peak.Cora)
asc.Cora <- asc.Cora[RealTime <= time.max & RealTime >= left]

growth.Cora <- asc.Cora[, .(slope = coef(lm(Ratio.norm ~ RealTime))[2]), by = c("Condition", "Label")]
```

```{r fig.width=15, fig.height=10}
growth.Cora[, pulse.length := str_extract(Condition, "[0-9]+(\\.[0-9]+)?")]
ggplot(growth.Cora, aes(x=Condition, y=slope)) + geom_boxplot(aes(fill=pulse.length)) + ggtitle("Growth rate estimated by linear fitting between peak half-maximum and maximum")  + theme(legend.position="top", text = element_text(size = 20)) + facet_wrap("pulse.length", nrow = 3, scales = "free_x")
```

Values and variances appear larger than for the other fit, but remain consistent. Both method could be applied. The half-maximum method has the advantage to do not rely on a evaluated (or somewhat arbitrary choose of) lag after stimulation.


# Using the wrapper

All methods used right above have been grouped in the script "single_peak_features.R". Be careful though, as it hasn't be thoroughly tested yet, especially the growth and decay rate for sampling rate different of 1min.

There will be some differences with the previous results for decay and growth rates using half-maximum, since the functions have been extended to also use the interpolated point at half maximum when performing the regressions.

```{r}
source("../rscripts/single_peak_features.R")
```

## On one example

Every feature described above has its own function, a wrapper computing all features at once is provided by FeatAllFeat. In the following example we compare what happens with or without trimming of the time axis:
```{r}
Cora <- Cora.cp

par(mfrow=c(1,2))
traj <- Cora[.("P5-I25",  "6_15"), Ratio.norm]
traj.trim <- Cora[Condition == "P5-I25" & Label == "6_15" & RealTime >= 10 & RealTime <= 25, Ratio.norm]

plot(seq_along(traj),traj, type = "b") 
lines(mySpline(seq_along(traj), traj, 30*length(traj))$x, mySpline(seq_along(traj), traj, 30*length(traj))$y, lty = "dashed", col = "red")
traj.fwhm <- FeatFWHM(traj)
abline(v=c(traj.fwhm$left, traj.fwhm$right), col = "blue", lty = "dashed")

plot(seq_along(traj.trim),traj.trim, type = "b") 
lines(mySpline(seq_along(traj.trim), traj.trim, 30*length(traj.trim))$x, mySpline(seq_along(traj.trim), traj.trim, 30*length(traj.trim))$y, lty = "dashed", col = "red")
traj.fwhm <- FeatFWHM(traj.trim)
abline(v=c(traj.fwhm$left, traj.fwhm$right), col = "blue", lty = "dashed")

as.data.table(FeatAllFeat(y = traj, basal = 1, start.lag.grow = 3, end.exp.dec = 11))
as.data.table(FeatAllFeat(y = traj.trim, basal = 1, start.lag.grow = 3, end.exp.dec = 11))
```

The feature outputs shows the clear advantage of the grow.half (resp. dec.half) over grow.lag (resp. dec.exp): they do not rely on the choice of hard time points. Clearly the time points here were chosen for the trimmed trajectory, that is why results somewhat random are found for the non-trimmed trajectory.

Differences in FWHM and left/right are very small, and come from the fact that these values are estimated based on a spline interpolation.

## On data

Will use the trimmed data here:
```{r cache = T}
Cora <- Cora.cp
Cora <- Cora[RealTime >= 10 & RealTime <= 25]

# Manual initialization to avoid conflict when NA are raised
all.feat.Cora <- unique(Cora[,c('Condition','Label')])
all.feat.Cora[, c("max.amp", "time.max.amp", "FWHM", "left", "right", "grow.half", "grow.lag", "dec.half", "dec.exp") := numeric(nrow(all.feat.Cora))]

for(k in 1:nrow(all.feat.Cora)){
  for(j in 3:ncol(all.feat.Cora)){
    features <- FeatAllFeat(Cora[Condition == all.feat.Cora[k, Condition] & Label == all.feat.Cora[k, Label], Ratio.norm], basal = 1, start.lag.grow = 3, end.exp.dec = 13)
    all.feat.Cora[k, j] <- features[[j-2]]
  }
}
all.feat.Cora[, pulse.length := str_extract(Condition, "[0-9]+(\\.[0-9]+)?")]

# The code would normally be as simple as:
#all.feat.Cora <- Cora[, c("max.amp", "time.max.amp", "FWHM", "left", "right", "grow.half", "grow.lag", "dec.half", "dec.exp") := FeatAllFeat(y = Ratio.norm, basal = 1, start.lag.grow = 3, end.exp.dec = 13), by = c("Condition", "Label")]
```

The wrapper returns almost the same results as the code above (at least by visual inspection and considering the slight changes in method). But the wrapper returns a very few large outliers when estimating the decay and growth rates (probably due to change of method), that are anyway easy to spot.