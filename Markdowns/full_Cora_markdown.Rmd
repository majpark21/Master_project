---
title: "Full analysis - Coralie dataset"
author: "Jacques Marc-Antoine"
date: "8 août 2017"
output:
  html_document:
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(width = 100)
```


# Load data and functions

Define the `Ratio` column as the ratio of fluo intensity in cytosol over nucleus.

```{r}
source("../rscripts/dist_mean.R")
source("../rscripts/overlap_clipping.R")
source("../rscripts/all_pairwise_stat.R")
source("../rscripts/sim_data.R")
source("../rscripts/amplitude_oscillations.R")
source("../rscripts/separability.R")

Cora <- fread("C:/Users/pixel/Dropbox/Marc-Antoine/data/set1-Coralie/tCoursesSelected.csv")
Cora[, Ratio := objCyto_Intensity_MeanIntensity_imErkCorrOrig / objNuc_Intensity_MeanIntensity_imErkCorrOrig]
setkey(Cora, Image_Metadata_Site, objNuc_TrackObjects_Label)
```

Trajectories are represented below:

![Dataset is divided in 8 conditions, with presence/absence of inhibitor and various stimulus intensities.](C:\Users\pixel\Desktop\Lectures\Semester_3\Master_thesis\Plot_coeherence\tCourses.png)

# Assess synchrony of the trajectories

## Compute the metrics

First we want a metric to define how synchronous trajectories are. We use 5 measures:

* Euclidean distance between individual trajectories and mean trajectory of the condition.
* Pairwise overlap of clipped trajectories (clipping: 1 if signal is increasing, 0 if signal is decreasing).
* Pairwise correlations of the trajectories in a condition (Pearson, Spearman based on ranks, Kendall based on concordant pairs)

k_roll_mean represents the width of the window for the rolling mean and should be set to the number of points per oscillation. Here in all oscillatory conditions, the period is roughly of 5 min (1 point/min).

```{r cache=TRUE, message=FALSE}
cond <- "Image_Metadata_Site"
tcol <- "RealTime"
mea <- "Ratio"
lab <- "objNuc_TrackObjects_Label"

Cora_mean <- dist_mean(data = Cora, condition = cond, tcol = tcol, measure = mea, label = lab, return.mean = F)
Cora_mean
Cora_pw <- all_pairwise_stats(data = Cora, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
Cora_pw
```

![Euclidean distance to mean trajectory](C:\Users\pixel\Desktop\Lectures\Semester_3\Master_thesis\Plot_coeherence\Coherence_stats_Cora_2.png)

***

![Pairwise metrics](C:\Users\pixel\Desktop\Lectures\Semester_3\Master_thesis\Plot_coeherence\Coherence_stats_Cora_1.png)

## Difference between distributions

Several possibilities here:

* ks statistics: [0,1]
* Bhattacharryya index: [0, +inf[
* Jeffries-Matusita: [0, sqrt(2)], transformed Bhatta.
* divergence (Kullback–Leibler?, close but not exactly that)
* transformed divergence (transformed Kullback–Leibler?)


### Distance to mean trajectory

```{r cache=T}
conds <- 0:7
comb <- combn(conds, 2)

sep.matrix <- matrix(unlist(
  apply(comb, 2, function(x) separability.measures(Cora_mean[Image_Metadata_Site==x[1], euclid_to_mean], Cora_mean[Image_Metadata_Site==x[2], euclid_to_mean])))
  , ncol=5, byrow = T)

sep.matrix <- cbind(t(comb), sep.matrix)
colnames(sep.matrix) <- c("Condition1", "Condition2", "jm", "bh", "div", "tdiv", "ks")
sep.matrix
```

If we represent only the oscillating conditons:

```{r fig.width=20, fig.height=12, echo=F, cache=T}
sep.melt <- melt(as.data.table(sep.matrix), id.vars = c("Condition1", "Condition2"))
ggplot(sep.melt[variable!="div" & Condition1 %in% c(1,3,5,7) & Condition2 %in% c(1,3,5,7)], aes(x=as.factor(Condition1), y= as.factor(Condition2), fill=value)) +
  geom_tile() +
  facet_grid(. ~ as.factor(variable)) +
  coord_equal() +
  theme(text = element_text(size=30), plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) +
  ggtitle("Distances between conditions - Distance to condition mean trajectory", "Assess synchronisation of oscillations")
```


### Overlap of clipped trajectories and pairwise correlations

We can for each of the 4 pairwise measures (overlap and 3 types of correlation) get a separability matrix just like above. (code hidden for the sake of clarity)

```{r echo=F, warning=F, message=F, fig.width=20, fig.height=20, cache=T}
sep.matrix.ovlp <- matrix(unlist(
  apply(comb, 2, function(x) separability.measures(Cora_pw[Image_Metadata_Site==x[1], Overlap], Cora_pw[Image_Metadata_Site==x[2], Overlap])))
  , ncol=5, byrow = T)
sep.matrix.ovlp <- as.data.table(cbind(t(comb), sep.matrix.ovlp))
colnames(sep.matrix.ovlp) <- c("Condition1", "Condition2", "jm", "bh", "div", "tdiv", "ks")
sep.matrix.ovlp$metrics <- "Overlap"

sep.matrix.pears <- matrix(unlist(
  apply(comb, 2, function(x) separability.measures(Cora_pw[Image_Metadata_Site==x[1], Pearson], Cora_pw[Image_Metadata_Site==x[2], Pearson])))
  , ncol=5, byrow = T)
sep.matrix.pears <- as.data.table(cbind(t(comb), sep.matrix.pears))
colnames(sep.matrix.pears) <- c("Condition1", "Condition2", "jm", "bh", "div", "tdiv", "ks")
sep.matrix.pears$metrics <- "Pearson"

sep.matrix.spear <- matrix(unlist(
  apply(comb, 2, function(x) separability.measures(Cora_pw[Image_Metadata_Site==x[1], Spearman], Cora_pw[Image_Metadata_Site==x[2], Spearman])))
  , ncol=5, byrow = T)
sep.matrix.spear <- as.data.table(cbind(t(comb), sep.matrix.spear))
colnames(sep.matrix.spear) <- c("Condition1", "Condition2", "jm", "bh", "div", "tdiv", "ks")
sep.matrix.spear$metrics <- "Spearman"

sep.matrix.kend <- matrix(unlist(
  apply(comb, 2, function(x) separability.measures(Cora_pw[Image_Metadata_Site==x[1], Kendall], Cora_pw[Image_Metadata_Site==x[2], Kendall])))
  , ncol=5, byrow = T)
sep.matrix.kend <- as.data.table(cbind(t(comb), sep.matrix.kend))
colnames(sep.matrix.kend) <- c("Condition1", "Condition2", "jm", "bh", "div", "tdiv", "ks")
sep.matrix.kend$metrics <- "Kendall"

sep.matrix <- rbind(sep.matrix.ovlp, sep.matrix.pears, sep.matrix.spear, sep.matrix.kend)

sep.melt <- melt(sep.matrix, id.vars = c("Condition1", "Condition2", "metrics"))
ggplot(sep.melt[variable!="div" & Condition1 %in% c(1,3,5,7) & Condition2 %in% c(1,3,5,7)], aes(x=as.factor(Condition1), y= as.factor(Condition2), fill=value)) +
  geom_tile() +
  facet_wrap(as.factor(metrics) ~ as.factor(variable)) +
  coord_equal() +
  theme(text = element_text(size=30), plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) +
  ggtitle("Distances between conditions - Pairwise overlap of clipped trajectories and Correlations", "Assess synchronisation of oscillations")
```

Essentially we see that in all oscillating conditions (1,3,5,7), trajectories are well synchronised and simply follow the stimulation rate (one pulse every 5min).


# Assess amplitude differences

## Euclidean distance to individual rolling mean

Another difference between these time series is the amplitude of the oscillations (when they are present). To assess this we measure for each individual trajectory its Euclidean distance to its OWN rolling mean. If set properly without a too important trend, the rolling mean "cut oscillations in 2" and has thus a null variation over an oscillation.

```{r message=F}
Cora_amp <- amplitude_oscillations(data = Cora, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
```

![Euclidean distance to individual rolling trajectory](C:\Users\pixel\Desktop\Lectures\Semester_3\Master_thesis\Plot_coeherence\Coherence_stats_Cora_3.png)

We can again use the previous metrics to quantify the differences between the distributions:

```{r}
sep.matrix <- matrix(unlist(
  apply(comb, 2, function(x) separability.measures(Cora_amp[Image_Metadata_Site==x[1], euclid_to_roll_mean], Cora_amp[Image_Metadata_Site==x[2], euclid_to_roll_mean])))
  , ncol=5, byrow = T)

sep.matrix <- cbind(t(comb), sep.matrix)
colnames(sep.matrix) <- c("Condition1", "Condition2", "jm", "bh", "div", "tdiv", "ks")
sep.matrix
```

If we represent only the oscillating conditons:

```{r fig.width=20, fig.height=12, echo=F}
sep.melt <- melt(as.data.table(sep.matrix), id.vars = c("Condition1", "Condition2"))
ggplot(sep.melt[variable!="div" & Condition1 %in% c(1,3,5,7) & Condition2 %in% c(1,3,5,7)], aes(x=as.factor(Condition1), y= as.factor(Condition2), fill=value)) +
  geom_tile() +
  facet_grid(. ~ as.factor(variable)) +
  coord_equal() +
  theme(text = element_text(size=30), plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) +
  ggtitle("Distances between conditions - Distance to individual Rolling Mean", "Assess amplitude of oscillations")
```


## Power of oscillation frequency

For this we will assume that all conditions oscillate at the same frequency, 0.2. The idea is to get the height of the peak for each trajectory in its power spectrum at this specific frequency. 

```{r cache=T, fig.width=20, fig.height=12}
# this doesn't work, but because freq 0.2 is always in 18th position so far...
#power_height <- Cora[, .(height = spectrum(Ratio, plot=F)$spec[which(spectrum(Ratio, plot = F)$freq == 0.2)]), by = c(cond, lab)]
power_height <- Cora[, .(height = spectrum(Ratio, plot=F)$spec[18]), by = c(cond, lab)]
power_height[, c("Image_Metadata_Site", "objNuc_TrackObjects_Label") := list(as.factor(Image_Metadata_Site), as.factor(objNuc_TrackObjects_Label))]

library(gridExtra)
p1 <- ggplot(power_height, aes(x= Image_Metadata_Site, y = height)) + geom_boxplot(aes(group=Image_Metadata_Site)) + ggtitle("Power at frequency 0.2", "Indicates amplitude of oscillations") + theme(axis.title = element_text(size = 30), plot.title = element_text(size = 30), plot.subtitle = element_text(size = 30))
p2 <- ggplot(power_height, aes(x = log(height), fill = Image_Metadata_Site, colour = Image_Metadata_Site)) + geom_density(alpha=0.1) + ggtitle("","") + facet_grid(Image_Metadata_Site ~ .) + theme(axis.title = element_text(size = 30))
grid.arrange(p1, p2, ncol = 2) 
```

```{r}
sep.matrix <- matrix(unlist(
  apply(comb, 2, function(x) separability.measures(power_height[Image_Metadata_Site==x[1], height], power_height[Image_Metadata_Site==x[2], height])))
  , ncol=5, byrow = T)

sep.matrix <- cbind(t(comb), sep.matrix)
colnames(sep.matrix) <- c("Condition1", "Condition2", "jm", "bh", "div", "tdiv", "ks")
sep.matrix
```

If we represent only the oscillating conditons:

```{r fig.width=20, fig.height=12, echo=F}
sep.melt <- melt(as.data.table(sep.matrix), id.vars = c("Condition1", "Condition2"))
ggplot(sep.melt[variable!="div" & Condition1 %in% c(1,3,5,7) & Condition2 %in% c(1,3,5,7)], aes(x=as.factor(Condition1), y= as.factor(Condition2), fill=value)) +
  geom_tile() +
  facet_grid(. ~ as.factor(variable)) +
  coord_equal() +
  theme(text = element_text(size=30), plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) +
  ggtitle("Power of signal at frequency 0.2", "Assess amplitude of oscillations")
```

# Alternative: SMETS

Method that compare directly conditions and assign a distance between them. It is based on the sum of Euclidean distances between matched trajectories, to which penalization is added to account for unmacthed trajectories. The penalization is proportionnal to the number of unmatched ts and to their information content (entropy).

Provided in a Matlab script (can run it with octave), results are:

```{r comment='', warning=F, message=F, echo=F, cache=T}
library(stringr)
library(data.table)
res <- readLines('../../SMETS/results.txt')
res2 <- c()
for(s in res){
  if(s != "") res2 <- c(res2, s)
}
res <- res2; rm(res2)

smets <- data.table(matrix(NA, nrow = length(res), ncol = 3))
colnames(smets) = c("Condition1", "Condition2", "SMETS")
smets$Condition1 <- as.factor(str_sub(res, 2, 2))
smets$Condition2 <- as.factor(str_sub(res, 3, 3))
smets$SMETS <- as.numeric(gsub(" = ", "", str_extract(res, " =  [0-9]+.[0-9]+")))

ggplot(smets, aes(x=Condition1, y= Condition2, fill=SMETS)) +
  geom_tile() +
  coord_equal() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) +
  ggtitle("SMETS", "Distance based on similarities between 2 conditions")
```

```{r}
smets
```


# Cross-Correlation stimulations vs trajectories

Find the best lag to align stimulus and signal. This gives the best possible correlation as well as the response time of the cells.

```{r fig.width=12}
get.max.cc <- function(ts1, ts2, plot = F, ...){
  temp <- ccf(ts1, ts2, plot = plot, ...)
  max.indx <- which.max(temp$acf)
  return(list(temp$acf[max.indx], temp$lag[max.indx]))
}

# Time series representing the stimuli, here one pulse every 5min starting at 11min til 66min
stim <- rep(0, 90)
stim[seq(11,66,5)] <- 1

cc.stim <- copy(Cora)
cc.stim[, c("max.cc", "best.lag") := get.max.cc(Ratio, stim, plot = F), by = .(Image_Metadata_Site, objNuc_TrackObjects_Label)]
cc.stim[, c("Image_Metadata_Site", "objNuc_TrackObjects_Label") := list(as.factor(Image_Metadata_Site), as.factor(objNuc_TrackObjects_Label))]

ggplot(cc.stim, aes(x = Image_Metadata_Site, y = max.cc)) + geom_boxplot(aes(group=Image_Metadata_Site))
ggplot(cc.stim, aes(x = Image_Metadata_Site, y = best.lag)) + geom_boxplot(aes(group=Image_Metadata_Site))
```

