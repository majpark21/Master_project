---
title: "Benchmarks - Cell synchrony"
author: "Jacques Marc-Antoine"
date: "2 ao√ªt 2017"
output:
  html_document:
    fig_width: 21
    fig_height: 21
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```


## 1. Function definition (hidden in html)

```{r echo=FALSE}
dist_mean <- function(data, condition, tcol, measure, label, return.mean = F){
  # data: a data table containing trajectories and conditions
  # condition: column name that fully define an experimental condition, thus a set of trajectories analyzed together
  # tcol: time column name
  # measure: column name with quantity of interest
  # label: column name with label of individual objects in each condition (cell label)
  
  require(data.table)
  # 1) Get mean trajectory for each condition
  means <- data[, .(Average = mean(get(measure))), by = c(condition, tcol)]
  dat <- merge(data[, c(condition, label, tcol, measure), with = F], means, by = c(condition, tcol))
  
  # 2) Euclidean distance between each trajectory and the mean one
  distances <- dat[, .(sq_dist = (get(measure) - Average)^2) , by = c(condition, label)]
  euclid <- distances[, .(euclid_to_mean = sqrt(sum(sq_dist))), by = c(condition, label)]
  
  if(return.mean){
    return(list(means = means, euclid = euclid))
  } else {
    return(euclid)
  }
}


rollex <- function(x, k = 5){
  # Extended rolling mean, fill the extremeties with linear approximation
  require(zoo)
  roll <- rollmean(x, k, na.pad = T)
  NonNAindex <- which(!is.na(roll))
  fst <- min(NonNAindex)
  lst <- max(NonNAindex)
  
  # Left and Right slopes
  lslope <- (roll[fst + 1] - roll[fst]) / 2
  rslope <- (roll[lst] - roll[lst - 1]) / 2
  
  # Replace NAs generated by roll with approx
  for(i in 1:(fst-1)){
    roll[i] <- roll[fst] + lslope * (i - fst) 
  }
  for(i in (lst+1):length(roll)){
    roll[i] <- roll[lst] + rslope * (i - lst) 
  }
  return(roll)
}


clip <- function(x, y){
  # Take two numeric vectors of same length, set x to 1 when above y and x to 0 when below y
  return(ifelse(x >= y, 1, 0))
}


wrap_clip <- function(x, k = 5){
  return(clip(x, rollex(x, k)))
}


overlap <- function(x, y){
  # How often do 2 clipped time series have the same value?
  temp <- ifelse(x==y,1,0)
  return(sum(temp)/length(temp))
}


sim_phase_shifted <- function(n, noise, freq = 1, len = 100, return.wide = F){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # len: length of simulations
  # return.wide: returns data in wide or long format
  
  require(data.table)
  # Create a matrix of shifted times 
  time_matrix <- matrix(seq(0, len-1, freq), nrow = len, ncol = n)
  shifts <- rnorm(n, 0, noise)
  shifts <- matrix(shifts, nrow = len, ncol = n, byrow = T)
  time_matrix <- time_matrix + shifts

  # Replace each shifted time by it sine function
  sins <- sin(time_matrix)
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, len-1, freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)  
  }
  
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_phase_shifted_with_fixed_trend <- function(n, noise, slope, freq = 1, len = 100){
  # Add a trend, i.e. a linear increase or decrease, to simulations
  # See sim_phase_shifted for arguments. Slope indicates the slope of the trend (change of mean value per unit of time)
  
  sins <- sim_phase_shifted(n, noise, freq,len, return.wide = F)
  trend_vec <- unique(sins$Time)
  trend_vec <- trend_vec * slope
  sins[, value := value + trend_vec, by = .(variable)]
  return(sins)
}


sim_noisy_amplitude <- function(n, noise, freq = 1, len = 100, return.wide = F){
  # Create a matrix of times and noise
  time_matrix <- matrix(seq(0, len-1, freq), nrow = len, ncol = n)
  noise_matrix <- replicate(n, rnorm(len, 0, noise))
  
  # Replace each shifted time by it sine function and add white noise
  sins <- sin(time_matrix)
  sins <- sins + noise_matrix
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, len-1, freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)  
  }
  
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


multi_sims <- function(type, noises, ...){
  # /!\ not optimized, growing data table
  # Generate multiple simulations of the indicated type.
  # noises: numeric vector with noise value, DO NOT PASS 0, as it is already used to initialize the output
  # ps: phase shifted
  # pst: phase shifted with linear trend
  # na: noisy amplitude
  
  if(!(type %in% c("ps", "pst", "na"))){
    stop("type must be one of c('ps', 'pst', 'na')")
  }
  
  # Initialize data.table with no noise
  if(type == "ps"){multi_sim <- sim_phase_shifted(noise = 0, ...)}
  else if(type == "pst"){multi_sim <- sim_phase_shifted_with_fixed_trend(noise = 0, ...)}
  else if(type == "na"){multi_sim <- sim_noisy_amplitude(noise = 0, ...)}
  
  multi_sim$noise <- 0
  for(noise in noises){
    if(type == "ps"){temp <- sim_phase_shifted(noise = noise, ...)}
    else if(type == "pst"){temp <- sim_phase_shifted_with_fixed_trend(noise = noise, ...)}
    else if(type == "na"){temp <- sim_noisy_amplitude(noise = noise, ...)}
    temp$noise <- noise
    multi_sim <- rbind(multi_sim, temp)
  }
  return(multi_sim)
}


plot_sim <- function(data, x = "Time", y = "value", group = "variable", use.facet = T, facet = "noise", alpha = 0.2){
  require(ggplot2)
  p <- ggplot(data, aes_string(x = x, y = y)) + geom_line(aes_string(group = group), alpha = alpha)
  p <- p + stat_summary(fun.y=mean, geom="line", colour = "blue", size = 1.5)
  if(use.facet){
    p <- p + facet_grid(as.formula(paste(facet, "~ .")))
  }
  p
}

all_pairwise_stats <- function(data, condition, label, measure, k_roll_mean = 5){
  # Compute all pairwise measures: overlap_clipping and correlations (Pearson, Spearman, Kendall)
  # The clipping of trajectories is performed as first step
  
  # data: a data table containing CLIPPED trajectories
  # condition: column name that fully define an experimental condition; MUST BE INTEGERS, NUMERIC, FACTOR OR CHARACTERS
  # measure: column name with clipped trajectories
  # label: column name with label of individual objects in each condition (cell label); LABELS MUST BE INTEGERS, NUMERIC, FACTOR OR CHARACTERS
  
  if(!(class(data[,get(condition)]) %in% c("integer", "numeric", "character", "factor"))){
    stop("Column 'condition' must be integer, numeric, factor or character.")
  }
  if(!(class(data[,get(label)]) %in% c("integer", "numeric", "character", "factor"))){
    stop("Column 'label' must be integer, numeric, factor or character.")
  }
  
  require(data.table)
  setkeyv(data, c(condition, label))
  
  # Perform clipping
  ClipData <- data[, .(clip_measure = wrap_clip(get(measure), k = k_roll_mean)), by = c(condition, label)]
  setkeyv(ClipData, c(condition, label))
  
  # Number of rows for data table initialization, sum of number of pairs in each condition
  nber_row <- 0
  for(i in unique(data[, get(condition)])){
    nber_row <- nber_row + choose(length(unique(data[.(i), get(label)])), 2)
  }

  
  # One row = one pair in one condition; set column types according to input types
  out <- data.table(matrix(ncol = 7, nrow = nber_row))
  colnames(out) <- c(condition, "Label1", "Label2", "Overlap", "Pearson", "Spearman", "Kendall")
  if(class(data[,get(condition)]) == "integer"){out[[condition]] <- as.integer(out[[condition]])}
  else if(class(data[,get(condition)]) == "numeric"){out[[condition]] <- as.numeric(out[[condition]])}
  else if(class(data[,get(condition)]) == "character"){out[[condition]] <- as.character(out[[condition]])}
  else if(class(data[,get(condition)]) == "factor"){out[[condition]] <- as.factor(out[[condition]])}
  
  
  if(class(data[,get(label)]) == "integer"){
    out[, Label1 := as.integer(Label1)]
    out[, Label2 := as.integer(Label2)]
  }
  else if(class(data[,get(label)]) == "numeric"){
    out[, Label1 := as.numeric(Label1)]
    out[, Label2 := as.numeric(Label2)]
  }
  else if(class(data[,get(label)]) == "character"){
    out[, Label1 := as.character(Label1)]
    out[, Label2 := as.character(Label2)]
  }
  else if(class(data[,get(label)]) == "factor"){
    out[, Label1 := as.factor(Label1)]
    out[, Label2 := as.factor(Label2)]
  }
  
  
  out[, Overlap := as.numeric(Overlap)]
  out[, Pearson := as.numeric(Pearson)]
  out[, Spearman := as.numeric(Spearman)]
  out[, Kendall := as.numeric(Kendall)]
  
  curr_row <- 1L
  # Loop condition
  for(i in unique(data[, get(condition)])){
    labels <- unique(data[.(i), get(label)])
    # Loop 1st label
    for(j in 1:(length(labels)-1)){
      # Loop 2nd label
      for(k in (j+1):length(labels)){
        set(out, curr_row, 1L, i)
        set(out, curr_row, 2L, labels[j])
        set(out, curr_row, 3L, labels[k])
        # /!\ use clip data for overlap
        set(out, curr_row, 4L, overlap(ClipData[.(i, labels[j]), clip_measure], ClipData[.(i, labels[k]), clip_measure]))
        set(out, curr_row, 5L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="pearson"))
        set(out, curr_row, 6L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="spearman"))
        set(out, curr_row, 7L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="kendall"))
        curr_row <- curr_row + 1L
      }
    }
  }
  return(out)
}
```



## 2. Data Simulation

```{r message=F}
n <- 50 # number of trajectories per noise level
noises <- seq(0.2, 3, 0.2)

# Phase shifted
ps <- multi_sims(type = "ps", noises = noises, n = n)
ps
# Phase shifted with trend
pst <- multi_sims(type = "pst", noises = noises, n = n, slope = 0.1)
# Amplitude noise
na <- multi_sims(type = "na", noises = noises, n = n)

plot_sim(ps)
plot_sim(pst)
plot_sim(na)
```

## 3. Distance to Mean

For each condition, this computes the distance between the average trajectory and each individual trajectory.

```{r}

cond <- "noise"
ti <- "Time"
mea <- "value"
lab <- "variable"

ps_mean <- dist_mean(data = ps, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
ps_mean
pst_mean <- dist_mean(data = pst, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
na_mean <- dist_mean(data = na, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
```

## 4. Pairwise Distances: Overlap clipping, Correlations Pearson, Spearman, Kendall

For each condition, take each pair of trajectories and compute the correlations between them (Pearson, Spearman and Kendall). In addition it clips the trajectories by comparison with their rolling means: whenever the trajectory is above its rolling mean, set it to 1 otherwise to 0. Finally for each pair of trajectories, the "overlap" metric, represents how often the trajectories of the pair have same value (i.e. 0.5 if complete random, 1 if they fully overlap).

This takes quite a while (partially) because it is implemented with for loops, but is still performed in reasonable time (i.e. a few minutes)

```{r message=F}
ps_pw <- all_pairwise_stats(data = ps, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
ps_pw
pst_pw <- all_pairwise_stats(data = pst, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
na_pw <- all_pairwise_stats(data = na, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
```


## 5. Plots of the distributions (code hidden in HTML)

#### Euclidean distance to the mean trajectory / !!! scale in y !!!

```{r message=F, echo=F, fig.height=10}
library(ggplot2)
library(gridExtra)

theme_update(plot.title = element_text(hjust = 0.5), text = element_text(size=15))

# Euclidean to Mean
p1 <- ggplot(ps_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted")
p2 <- ggplot(pst_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend")
p3 <- ggplot(na_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude")
grid.arrange(p1, p2, p3, ncol = 3)
```

#### Pairwise Overlap of clipped trajectories

```{r message=F, echo=F, fig.height=10}
# Overlap
p1 <- ggplot(ps_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(0,1))
p2 <- ggplot(pst_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(0,1))
p3 <- ggplot(na_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(0,1))
grid.arrange(p1, p2, p3, ncol = 3)
```


#### Pairwise Pearson correlations

```{r message=F, echo=F, fig.height=10}
p1 <- ggplot(ps_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
p2 <- ggplot(pst_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
p3 <- ggplot(na_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(p1, p2, p3, ncol = 3)
```

#### Pairwise Spearman correlations

```{r message=F, echo=F, fig.height=10}
p1 <- ggplot(ps_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
p2 <- ggplot(pst_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
p3 <- ggplot(na_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(p1, p2, p3, ncol = 3)
```

#### Pairwise Kendall correlations

```{r message=F, echo=F, fig.height=10}
p1 <- ggplot(ps_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
p2 <- ggplot(pst_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
p3 <- ggplot(na_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(p1, p2, p3, ncol = 3)
```


## 6. Relations between the metrics

```{r}
cor(ps_pw[, 4:7])
cor(pst_pw[, 4:7])
cor(na_pw[, 4:7])
```


## 7. How to go from a distribution to a single value for each metrics

#### Distance to mean trajectory

For each condition, count the proportion of trajectories that are lying more than x standard deviation from the mean (conversion to z-score first?).


#### Correlations and Overlap

Get a p-value:
Assume that they are normally distributed, check that the distributions lies above 0 for correlations and above 0.5 for clipping (t-test).

```{r}
ps_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]

pst_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]

na_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]
```


