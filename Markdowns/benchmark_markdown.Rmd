---
title: "Benchmarks - Cell synchrony and 'causality'"
author: "Jacques Marc-Antoine"
date: "2 ao√ªt 2017"
output:
  html_document:
    fig_width: 21
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```


# Function definition (hidden in html)

```{r echo=FALSE}
dist_mean <- function(data, condition, tcol, measure, label, return.mean = F){
  # data: a data table containing trajectories and conditions
  # condition: column name that fully define an experimental condition, thus a set of trajectories analyzed together
  # tcol: time column name
  # measure: column name with quantity of interest
  # label: column name with label of individual objects in each condition (cell label)
  
  require(data.table)
  # 1) Get mean trajectory for each condition
  means <- data[, .(Average = mean(get(measure))), by = c(condition, tcol)]
  dat <- merge(data[, c(condition, label, tcol, measure), with = F], means, by = c(condition, tcol))
  
  # 2) Euclidean distance between each trajectory and the mean one
  distances <- dat[, .(sq_dist = (get(measure) - Average)^2) , by = c(condition, label)]
  euclid <- distances[, .(euclid_to_mean = sqrt(sum(sq_dist))), by = c(condition, label)]
  
  if(return.mean){
    return(list(means = means, euclid = euclid))
  } else {
    return(euclid)
  }
}


rollex <- function(x, k = 5){
  # Extended rolling mean, fill the extremeties with linear approximation
  require(zoo)
  roll <- rollmean(x, k, na.pad = T)
  NonNAindex <- which(!is.na(roll))
  fst <- min(NonNAindex)
  lst <- max(NonNAindex)
  
  # Left and Right slopes
  lslope <- (roll[fst + 1] - roll[fst]) / 2
  rslope <- (roll[lst] - roll[lst - 1]) / 2
  
  # Replace NAs generated by roll with approx
  for(i in 1:(fst-1)){
    roll[i] <- roll[fst] + lslope * (i - fst) 
  }
  for(i in (lst+1):length(roll)){
    roll[i] <- roll[lst] + rslope * (i - lst) 
  }
  return(roll)
}


clip <- function(x, y){
  # Take two numeric vectors of same length, set x to 1 when above y and x to 0 when below y
  return(ifelse(x >= y, 1, 0))
}


wrap_clip <- function(x, k = 5){
  return(clip(x, rollex(x, k)))
}


overlap <- function(x, y){
  # How often do 2 clipped time series have the same value?
  temp <- ifelse(x==y,1,0)
  return(sum(temp)/length(temp))
}


sim_phase_shifted <- function(n, noise, freq = 1, end = 100, return.wide = F){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # end: end time of simulations
  # return.wide: returns data in wide or long format
  
  require(data.table)
  # If sampling rate < 1, adjust end such that seq(from, to, by) re
  
  # Create a matrix of shifted times 
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  shifts <- rnorm(n, 0, noise)
  shifts <- matrix(shifts, nrow = length(tvec), ncol = n, byrow = T)
  time_matrix <- time_matrix + shifts

  # Replace each shifted time by it sine function
  sins <- sin(time_matrix)
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)  
  }
  
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_phase_shifted_damped <- function(n, noise, dampen_params, freq = 1, end = 100){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # end: end time of simulations
  # dampen_params: c(initial amplitude, dampen rate)
  
  require(data.table)
  
  # Create a matrix of shifted times 
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  shifts <- rnorm(n, 0, noise)
  shifts <- matrix(shifts, nrow = length(tvec), ncol = n, byrow = T)
  time_matrix <- time_matrix + shifts
  
  # Replace each shifted time by it sine function
  sins <- sin(time_matrix) * dampen_params[1] * exp(-dampen_params[2]*time_matrix)
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_phase_shifted_with_fixed_trend <- function(n, noise, slope, freq = 1, end = 100){
  # Add a trend, i.e. a linear increase or decrease, to simulations
  # See sim_phase_shifted for arguments. Slope indicates the slope of the trend (change of mean value per unit of time)
  
  sins <- sim_phase_shifted(n, noise, freq, end, return.wide = F)
  trend_vec <- unique(sins$Time)
  trend_vec <- trend_vec * slope
  sins[, value := value + trend_vec, by = .(variable)]
  return(sins)
}


sim_noisy_amplitude <- function(n, noise, freq = 1, end = 100, return.wide = F){
  # Create a matrix of times and noise
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  noise_matrix <- replicate(n, rnorm(length(tvec), 0, noise))
  
  # Replace each shifted time by it sine function and add white noise
  sins <- sin(time_matrix)
  sins <- sins + noise_matrix
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)  
  }
  
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_noisy_amplitude_damped <- function(n, noise, dampen_params, freq = 1, end = 100){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # end: end time of simulations
  # dampen_params: c(initial amplitude, dampen rate)
  
  require(data.table)
  
  # Create a matrix of times and noise
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  noise_matrix <- replicate(n, rnorm(length(tvec), 0, noise))
  
  # Replace each shifted time by it sine function
  sins <- sin(time_matrix) * dampen_params[1] * exp(-dampen_params[2]*time_matrix)
  sins <- sins + noise_matrix
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}



sim_expodecay_lagged_stim <- function(n, noise, interval.stim = 5, lambda = 0.2, freq = 1, end = 100, return.wide = F){
  # A fucntion to simulate a population of n trajectories of expo decay, that are taken up at regular time by stimulus.
  # The noise add a lag between the stimulus and the increase.
  # n: number of trajectories
  # noise: standard deviation for the lag
  # interval.stim: how long between each stimulation?
  # lambda: desintegration rate
  # freq: sampling rate (in time unit), how often do we compute the state of the system
  # end: end time of simulations
  # return.wide: returns data in wide or long format
  
  # Time vector
  tvec <- seq(0, end-1, by = freq)
  # Matrix with stimulation times
  stim_time <- seq(interval.stim, end-1 , interval.stim)
  stim_time_matrix <- matrix(stim_time, nrow = length(stim_time), ncol = n)
  
  # Randomize the stimulation times (represent random lag), forbid lag < 0
  noise_matrix <- abs(replicate(n, rnorm(n = length(stim_time), mean = 0, sd = noise)))
  stim_time_matrix <- stim_time_matrix + noise_matrix
  
  # Initialize trajectories with 0 everywhere, set to 1 at stimulus times
  trajs <- matrix(0, nrow = length(tvec), ncol = n)
  for(col in 1:ncol(stim_time_matrix)){
    for(row in 1:nrow(stim_time_matrix)){
      index <- which(tvec >= stim_time_matrix[row, col])[1]
      trajs[index, col] <- 1
    }
  }
  
  # Expo decay computed thanks to previous value
  decrease_factor <- exp(-lambda * freq)
  for(col in 1:ncol(trajs)){
    for(row in 2:nrow(trajs)){
      # If not at a stim time, decay
      if(trajs[row, col] != 1){trajs[row, col] <- trajs[row-1, col] * decrease_factor}
    }
  }
  
  # Go to data.table
  trajs <- as.data.table(trajs)
  trajs <- cbind(seq(0, end-1, by = freq), trajs)
  colnames(trajs)[1] <- "Time"
  if(return.wide){
    return(trajs)  
  }
  
  # Format long data table
  trajs <- melt(trajs, id.vars = "Time")
  return(trajs)
}


multi_sims <- function(type, noises, ...){
  # /!\ not optimized, growing data table
  # Generate multiple simulations of the indicated type.
  # noises: numeric vector with noise value, DO NOT PASS 0, as it is already used to initialize the output
  # ps: phase shifted
  # pst: phase shifted with linear trend
  # psd: phase shifted damped
  # na: noisy amplitude
  # nad: noisy amplitude damped
  # edls: expo decay lagged stimulation
  
  if(!(type %in% c("ps", "pst", "psd", "na", "nad", "edls"))){
    stop("type must be one of c('ps', 'pst', 'psd', 'na', 'nad', 'edls')")
  }
  
  # Initialize data.table with no noise
  if(type == "ps"){multi_sim <- sim_phase_shifted(noise = 0, ...)}
  else if(type == "pst"){multi_sim <- sim_phase_shifted_with_fixed_trend(noise = 0, ...)}
  else if(type == "psd"){multi_sim <- sim_phase_shifted_damped(noise = 0, ...)}
  else if(type == "na"){multi_sim <- sim_noisy_amplitude(noise = 0, ...)}
  else if(type == "nad"){multi_sim <- sim_noisy_amplitude_damped(noise = 0, ...)}
  else if(type == "edls"){multi_sim <- sim_expodecay_lagged_stim(noise = 0, ...)}
  
  multi_sim$noise <- 0
  for(noise in noises){
    if(type == "ps"){temp <- sim_phase_shifted(noise = noise, ...)}
    else if(type == "pst"){temp <- sim_phase_shifted_with_fixed_trend(noise = noise, ...)}
    else if(type == "psd"){temp <- sim_phase_shifted_damped(noise = noise, ...)}
    else if(type == "na"){temp <- sim_noisy_amplitude(noise = noise, ...)}
    else if(type == "nad"){temp <- sim_noisy_amplitude_damped(noise = noise, ...)}
    else if(type == "edls"){temp <- sim_expodecay_lagged_stim(noise = noise, ...)}
    temp$noise <- noise
    multi_sim <- rbind(multi_sim, temp)
  }
  return(multi_sim)
}



plot_sim <- function(data, x = "Time", y = "value", group = "variable", use.facet = T, facet = "noise", alpha = 0.2){
  require(ggplot2)
  p <- ggplot(data, aes_string(x = x, y = y)) + geom_line(aes_string(group = group), alpha = alpha)
  p <- p + stat_summary(fun.y=mean, geom="line", colour = "blue", size = 1.5)
  if(use.facet){
    p <- p + facet_grid(as.formula(paste(facet, "~ .")))
  }
  p
}


all_pairwise_stats <- function(data, condition, label, measure, k_roll_mean = 5){
  # Compute all pairwise measures: DTW, overlap_clipping and correlations (Pearson, Spearman, Kendall)
  # The clipping of trajectories is performed as first step
  
  # data: a data table containing CLIPPED trajectories
  # condition: column name that fully define an experimental condition; MUST BE INTEGERS, NUMERIC, FACTOR OR CHARACTERS
  # measure: column name with clipped trajectories
  # label: column name with label of individual objects in each condition (cell label); LABELS MUST BE INTEGERS, NUMERIC, FACTOR OR CHARACTERS
  
  if(!(class(data[,get(condition)]) %in% c("integer", "numeric", "character", "factor"))){
    stop("Column 'condition' must be integer, numeric, factor or character.")
  }
  if(!(class(data[,get(label)]) %in% c("integer", "numeric", "character", "factor"))){
    stop("Column 'label' must be integer, numeric, factor or character.")
  }
  
  require(data.table)
  require(dtw)
  setkeyv(data, c(condition, label))
  
  # Perform clipping
  ClipData <- data[, .(clip_measure = wrap_clip(get(measure), k = k_roll_mean)), by = c(condition, label)]
  setkeyv(ClipData, c(condition, label))
  
  # Number of rows for data table initialization, sum of number of pairs in each condition
  nber_row <- 0
  for(i in unique(data[, get(condition)])){
    nber_row <- nber_row + choose(length(unique(data[.(i), get(label)])), 2)
  }

  
  # One row = one pair in one condition; set column types according to input types
  out <- data.table(matrix(ncol = 8, nrow = nber_row))
  colnames(out) <- c(condition, "Label1", "Label2", "Overlap", "Pearson", "Spearman", "Kendall", "DTW")
  if(class(data[,get(condition)]) == "integer"){out[[condition]] <- as.integer(out[[condition]])}
  else if(class(data[,get(condition)]) == "numeric"){out[[condition]] <- as.numeric(out[[condition]])}
  else if(class(data[,get(condition)]) == "character"){out[[condition]] <- as.character(out[[condition]])}
  else if(class(data[,get(condition)]) == "factor"){out[[condition]] <- as.factor(out[[condition]])}
  
  
  if(class(data[,get(label)]) == "integer"){
    out[, Label1 := as.integer(Label1)]
    out[, Label2 := as.integer(Label2)]
  }
  else if(class(data[,get(label)]) == "numeric"){
    out[, Label1 := as.numeric(Label1)]
    out[, Label2 := as.numeric(Label2)]
  }
  else if(class(data[,get(label)]) == "character"){
    out[, Label1 := as.character(Label1)]
    out[, Label2 := as.character(Label2)]
  }
  else if(class(data[,get(label)]) == "factor"){
    out[, Label1 := as.factor(Label1)]
    out[, Label2 := as.factor(Label2)]
  }
  
  out[, Overlap := as.numeric(Overlap)]
  out[, Pearson := as.numeric(Pearson)]
  out[, Spearman := as.numeric(Spearman)]
  out[, Kendall := as.numeric(Kendall)]
  out[, DTW := as.numeric(DTW)]
  
  curr_row <- 1L
  # Loop condition
  for(i in unique(data[, get(condition)])){
    labels <- unique(data[.(i), get(label)])
    # Loop 1st label
    for(j in 1:(length(labels)-1)){
      # Loop 2nd label
      for(k in (j+1):length(labels)){
        set(out, curr_row, 1L, i)
        set(out, curr_row, 2L, labels[j])
        set(out, curr_row, 3L, labels[k])
        # /!\ use clip data for overlap
        set(out, curr_row, 4L, overlap(ClipData[.(i, labels[j]), clip_measure], ClipData[.(i, labels[k]), clip_measure]))
        set(out, curr_row, 5L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="pearson"))
        set(out, curr_row, 6L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="spearman"))
        set(out, curr_row, 7L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="kendall"))
        set(out, curr_row, 8L, dtw(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)])$distance)
        curr_row <- curr_row + 1L
      }
    }
  }
  return(out)
}


complete.time.series <- function(data, cond.col, lab.col, time.col, time.vector, meas.col, fill = NA){
  # Add a row with fill measurement for all missing measurement in the long format
  # time vector: over which time should ALL time series span? Missing times will be added to series where it's not present
  require(data.table)
  # 1) Perform left outer join with a table that contains all RealTime
  temp <- CJ(Condition=unique(data[[cond.col]]), Label=unique(data[[lab.col]]), RealTime=time.vector)
  temp <- merge(temp, data, by = c(cond.col, lab.col, time.col), all.x = T)
  # 2) Trim the rows that contains only NA (i.e. this combination of Label and Condition does not exist in the real data)
  out <- temp[, if(!all(is.na(get(meas.col)))) .SD, by = .(Condition, Label)]
  return(out)
}

```



# Data Simulation

```{r message=F, fig.height=21}
n <- 50 # number of trajectories per noise level
noises <- seq(0.2, 3, 0.2)
freq <- 1 # compute sinus every 1 time unit

# Phase shifted
ps <- multi_sims(type = "ps", noises = noises, n = n, freq = freq)
ps
# Phase shifted with trend
pst <- multi_sims(type = "pst", noises = noises, n = n, slope = 0.1, freq = freq)
# Amplitude noise
na <- multi_sims(type = "na", noises = noises, n = n, freq = freq)

plot_sim(ps)
plot_sim(pst)
plot_sim(na)
```

# Distance to Mean

For each condition, this computes the distance between the average trajectory and each individual trajectory.

```{r}

cond <- "noise"
ti <- "Time"
mea <- "value"
lab <- "variable"

ps_mean <- dist_mean(data = ps, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
ps_mean
pst_mean <- dist_mean(data = pst, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
na_mean <- dist_mean(data = na, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
```

# Pairwise Distances: Overlap clipping, Correlations Pearson, Spearman, Kendall

For each condition, take each pair of trajectories and compute the correlations between them (Pearson, Spearman and Kendall). In addition it clips the trajectories by comparison with their rolling means: whenever the trajectory is above its rolling mean, set it to 1 otherwise to 0. Finally for each pair of trajectories, the "overlap" metric, represents how often the trajectories of the pair have same value (i.e. 0.5 if complete random, 1 if they fully overlap).

This takes quite a while (partially) because it is implemented with for loops, but is still performed in reasonable time (i.e. a few minutes)

```{r message=F}
ps_pw <- all_pairwise_stats(data = ps, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
ps_pw
pst_pw <- all_pairwise_stats(data = pst, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
na_pw <- all_pairwise_stats(data = na, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
```


# Plots of the distributions (code hidden in HTML)

## Euclidean distance to the mean trajectory / !!! scale in y !!!

```{r message=F, echo=F, fig.height=10}
library(ggplot2)
library(gridExtra)

theme_update(plot.title = element_text(hjust = 0.5), text = element_text(size=15))

# Euclidean to Mean
p1 <- ggplot(ps_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted")
p2 <- ggplot(pst_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend")
p3 <- ggplot(na_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude")
grid.arrange(p1, p2, p3, ncol = 3)
```

## Pairwise Overlap of clipped trajectories

```{r message=F, echo=F, fig.height=10}
# Overlap
q1 <- ggplot(ps_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(0,1))
q2 <- ggplot(pst_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(0,1))
q3 <- ggplot(na_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(0,1))
grid.arrange(q1, q2, q3, ncol = 3)
```


## Pairwise Pearson correlations

```{r message=F, echo=F, fig.height=10}
r1 <- ggplot(ps_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
r2 <- ggplot(pst_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
r3 <- ggplot(na_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(r1, r2, r3, ncol = 3)
```

## Pairwise Spearman correlations

```{r message=F, echo=F, fig.height=10}
s1 <- ggplot(ps_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
s2 <- ggplot(pst_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
s3 <- ggplot(na_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(s1, s2, s3, ncol = 3)
```

## Pairwise Kendall correlations

```{r message=F, echo=F, fig.height=10}
t1 <- ggplot(ps_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
t2 <- ggplot(pst_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
t3 <- ggplot(na_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(t1, t2, t3, ncol = 3)
```

## Pairwise Dynamic Time warping

```{r message=F, echo=F, fig.height=10}
u1 <- ggplot(ps_pw, aes(x = noise, y = DTW)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") 
u2 <- ggplot(pst_pw, aes(x = noise, y = DTW)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") 
u3 <- ggplot(na_pw, aes(x = noise, y = DTW)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude")
grid.arrange(u1, u2, u3, ncol = 3)
```




# Relations between the metrics

```{r}
cor(ps_pw[, 4:8])
cor(pst_pw[, 4:8])
cor(na_pw[, 4:8])
```


# How to go from a distribution to a single value for each metrics

## Distance to mean trajectory

For each condition, count the proportion of trajectories that are lying more than x standard deviation from the mean (conversion to z-score first?).


## Correlations and Overlap

Get a p-value:
Assume that they are normally distributed, check that the distributions lies above 0 for correlations and above 0.5 for clipping (t-test).

```{r}
ps_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]

pst_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]

na_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]
```


# Effect of window size in rolling mean for clipped trajectories


If we increase sampling rate, it means that there is more points per oscillation. Visually this means that the average trajectory is smoother. 

```{r}
plot_sim(sim_phase_shifted(n = 50, noise = 0.4, freq = 2), use.facet = F)
plot_sim(sim_phase_shifted(n = 50, noise = 0.4, freq = 0.2), use.facet = F)
```


The role of the rolling mean in clipping, is to "cut the oscillation in 2". A good case is like:

```{r}
# Contains 6 to 7 points per oscillation
sim <- sim_phase_shifted(n = 1, noise = 0, freq = 1)
plot(sim$Time, sim$value, type = "b")
lines(x=sim$Time, y=rollex(sim$value, k = 6), col = "red", lwd = 1.5)

# clip trajectory and scale for clarity on the plot
clip_traj <- wrap_clip(x = sim$value, k = 6)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x=sim$Time, y=clip_traj, col = "blue", type = "S")
```

It is a good case since the rolling mean (in red), cuts the trajectory (in black) at half-period (i.e. near to 0). This results in a clipped trajectory (in blue) that is up when the oscillation is "above 0" and down when its "below 0".

Now we multiply the sampling rate by 5, but keep the same window size for the moving average in the top case, and multiply it also by 5 in the bottom case:

```{r fig.height=15}
par(mfrow = c(2,1))
# Contains more than 35 points per oscillation
sim <- sim_phase_shifted(n = 1, noise = 0, freq = 0.2)

size_window <- 6
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")

size_window <- 35
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")
```

As we can see the moving average follows the signal perfectly with the small window, whereas it is out of phase with the larger window with much smaller amplitude. Clipping trajectory is ok in both cases. Nevertheless the top case is bad, why? Don't forget that we've been working with perfect sinusoid so far, let's see what happens with a tiny bit of noise in the amplitude of the signal:

```{r fig.height=15}
par(mfrow = c(2,1))
# Contains more than 35 points per oscillation
sim <- sim_noisy_amplitude(n = 1, noise = 0.1, freq = 0.2)

size_window <- 6
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")

size_window <- 35
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")
```

As we observe, clipped trajectory becomes completely random with the small window, whereas it remains identical with the larger one. So we should choose the window size for the rolling mean such that it covers the number of points in an oscillation. 


On multiple simulations the distributions look like:

```{r}
# Already defined in section 4.
# na <- multi_sims(type = "na", noises = noises, n = n, freq = 1)
# na_pw <- all_pairwise_stats(data = na, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
# q3 <- ggplot(na_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(0,1))

na_high_freq <- multi_sims(type = "na", noises = noises, n = n, freq = 0.2)
na_high_freq_pw <- all_pairwise_stats(data = na_high_freq, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
```

```{r fig.height = 10}
q3_high <- ggplot(na_high_freq_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Window Size: 5; Freq: 0.2 (window too small)") + scale_y_continuous(limits = c(0,1))
grid.arrange(q3 + ggtitle("Window Size: 5; Freq: 1 (window of the right size)"), q3_high, ncol = 2)
```


# Synchrony between cell and stimulus ("causality") - Maximum cross-correlation / convolution

## Simulation: pulsed and lagged exponential decay
To assess this we define a new kind of simulations, which are made of "pulsed" exponential decays. The signal behaves as regular exponential decay but once in a while, a stimulus brings the signal back to its maximum (i.e. 1). The noise in these simulation is a random lag between the time at which the stimulus is applied and the time at which the signal is effectively going up. 

```{r fig.height=21}
# edls: exponential decay with lagged stimulation; 5 time units between each pulse
edls <- multi_sims(type = "edls", noises = noises, n = n, freq = 0.2, interval.stim = 5)
plot_sim(edls)
```

## Stimuli representation
We can represent the stimuli pattern by another time series:
```{r}
# Array of 0 of the same length as a trajectory
stim <- rep(0, 496)
stim[seq(25,496,25)] <- 1

# Plot a trajectory without lag along with the stimulation pattern
plot(edls[variable=="V1" & noise==0, value], type = "l", lwd = 2)
lines(stim, type="s", col = "blue", lwd = 1)
```

## Optimal lag and maximal cross-correlation

Cross-correlation (or convolution, definitions seems to vary from one author to another, but it's the same operation provided that we've flipped the stimulation pattern beforehand and have normalized the output; convolution is easier to interprete as a weighted average of one signal, weights being given by the other signal) computes an array of correlations of one signal by sliding another signal on it. The higher this correlation the more the curves look alike with the given sliding shift (lag).

```{r fig.width=12, fig.align="center"}
ccf(edls[variable=="V1" & noise==0, value], stim, ylab = "Correlation coefficient")
cor(edls[variable=="V1" & noise==0, value], stim)
```

We see that the correlation without shift is actually negative whereas it is maximal if we shift the stimulation pattern by 1. The optimal lag is 1 and not 0 due to the way simulations were built. Provided that we sample the signal every 0.2 time unit, see `edls <- multi_sims(type = "edls", noises = noises, n = n, freq = 0.2, interval.stim = 5)`, this would mean that the cells max response happens 0.2 time unit after the stimulus (once again here we should read 0, but it's an artefact of the simulation building).

Here we'll isolate the highest peak of cross-correlation between each trajectory and the stimulation pattern to essentially look at 2 things: the height of the peak which should inform about the strength of the association (the "causality" of the stimulation on the signal) and the associated lag (how long does it take for the cells to fully respond to the signal).

```{r fig.width=12}
get.max.cc <- function(ts1, ts2, plot = F, ...){
  temp <- ccf(ts1, ts2, plot = plot, ...)
  max.indx <- which.max(temp$acf)
  return(list(temp$acf[max.indx], temp$lag[max.indx]))
}

cc.stim <- copy(edls)
cc.stim[, c("max.cc", "lag") := get.max.cc(value, stim, plot = F), by = .(noise, variable)]
cc.stim[, noise := as.factor(noise)]

ggplot(cc.stim, aes(x = noise, y = max.cc)) + geom_boxplot(aes(group=noise))
ggplot(cc.stim, aes(x = noise, y = lag)) + geom_boxplot(aes(group=noise))
```

Note that in these simulations the lag is random for each pulse within a single trajectory, we might expect the cells to have a more robust response that will always provide "more or less" the same lag. In other words, in the simulations we add a mirrored normal noise centered around 0 to determine the lag and change the sd according to the noise, but we could also change the mean of the normal distribution.


## Unsensitivity to signal amplitude (without noise)

Insensitive to input amplitude: 

```{r fig.width=12}
cc.stim[, value := value * 3]
cc.stim[, c("max.cc", "lag") := get.max.cc(value, stim, plot = F), by = .(noise, variable)]

ggplot(cc.stim, aes(x = noise, y = max.cc)) + geom_boxplot(aes(group=noise))
ggplot(cc.stim, aes(x = noise, y = lag)) + geom_boxplot(aes(group=noise))
```

Exactly same results as before.

## Sensitivity to noise in amplitude

We perform simulations without lag in the response, but add white noise to the signal amplitude:

```{r fig.height=21}
# Run the simulation without lag in response 15 times (14 + 1 internally computed)
edls <- multi_sims(type = "edls", noises = rep(0, 14), n = n, freq = 0.2, interval.stim = 5)

# Add the white noise with different sd
nber.per.condition <- 496 * n  # 496 data points per trajectory 
# Define the levels of noise
nois <- rep(seq(0, 0.56, 0.04), each = nber.per.condition)
edls$noise <- nois
# Produce the noise and add it
nois <- sapply(nois, function(x) 0 + rnorm(1, mean = 0, sd = x))
edls[, value := value + nois]

plot_sim(edls)
```

Even though the mean trajectory look alike along noise level, individual trajectories get completly denatured with the highest levels of noise. Remember that the signal vary between 0 and 1; for a noise level of 0.28, the probability to get a noise of 0.1 or more is: `r 1-pnorm(0.1, 0, 0.28)`; it becomes `r 1-pnorm(0.1, 0, 0.56)` for a noise level of 0.56.

```{r fig.width=12, fig.height=12}
par(mfrow = c(3,1))
plot(edls[variable == "V1" & noise == 0, value], type = "l"); abline(h=c(0,1), lty='dashed')
plot(edls[variable == "V1" & noise == 0.28, value], type = "l"); abline(h=c(0,1), lty='dashed')
plot(edls[variable == "V1" & noise == 0.56, value], type = "l"); abline(h=c(0,1), lty='dashed')
```


Effect on cross-correlation with the stimulation pattern:

```{r fig.width=12}
cc.stim <- copy(edls)
cc.stim[, c("max.cc", "lag") := get.max.cc(value, stim, plot = F), by = .(noise, variable)]
cc.stim[, noise := as.factor(noise)]

ggplot(cc.stim, aes(x = noise, y = max.cc)) + geom_boxplot(aes(group=noise))
ggplot(cc.stim, aes(x = noise, y = lag)) + geom_boxplot(aes(group=noise))
```

We see that CC is much less sensitive to noise in amplitude than to noise in lag before response.


# Long-term trend regression

We introduce damped sinusoids simulations with noise in phase and a linear decrease.

```{r fig.height=21}
# psd: phase_shifted_damped, dampen_params: c(inital amplitude, decay rate)
nad <- multi_sims(type = "nad", noises = noises, n = n, dampen_params = c(1, 0.01))
# Add linear trend
nad[, value := value + seq(0, -0.5, length.out = 100)]
# Moving average
nad[, moving_average := rollex(x = value, k = 6), by = c("noise", "variable")]
plot_sim(nad) + scale_y_continuous(limits = c(-1.5,1.5))
```

We want try 2 different metrics for estimating the long-term decrease: the slope of linear regression of moving average, and the slope after maxima fitting:

## Linear regression of moving average

```{r, fig.height=21}
slope_ma <- nad[, .(slope = coef(lm(moving_average ~ Time))[2]), by = c("noise", "variable")]
ggplot(slope_ma, aes(x=as.factor(noise),y=slope)) + geom_boxplot(aes(fill=noise)) + theme(text = element_text(size = 45)) + ggtitle("Slopes from moving average")
```

## Regression on maxima

```{r}
detect.maxima <- function(x, window.size){
  require(zoo)
  if(window.size %% 2 == 0) stop("window size must be odd")
  middle <- ceiling(window.size / 2)
  xz <- as.zoo(x)
  out <- rollapply(x, window.size, function(x) which.max(x) == middle)
  out <- c(rep(NA, middle-1), out, rep(NA, middle-1))
  return(out)
}

detect.minima <- function(x, window.size){
  require(zoo)
  if(window.size %% 2 == 0) stop("window size must be odd")
  middle <- ceiling(window.size / 2)
  xz <- as.zoo(x)
  out <- rollapply(x, window.size, function(x) which.min(x) == middle)
  out <- c(rep(NA, middle-1), out, rep(NA, middle-1))
  return(out)
}

wrap_max_reg <- function(traj, window.size, min.index, max.index, robust = F){
  # min.index, max.index delimits the region of interest where we are looking for maxima
  
  # 0) Adjust window size to an odd number
  if(window.size == 10){window.size <- 9}
  else if(window.size == 20){window.size <- 19}
  
  # 1) Where are the maxima
  max.pos <- which(detect.maxima(traj, window.size))
  # Keep only maxima occuring at time > min.index
  max.pos <- max.pos[max.pos >= min.index & max.pos <= max.index]
  nber <- length(max.pos)
  max.traj <- traj[max.pos]
  
  # 2) Perform the fitting
  # If no maxima detected, run simple linear regression, not only on maxima (not robust as this results in an error)
  if(robust){
    require(mblm)
    fit <- try(mblm(max.traj ~ max.pos))
    if(class(fit)== "try-error"){
      nber <- numeric(0)
      fit <- lm(traj ~ seq_along(traj))
    }
    p.val <- try(coef(summary(fit))[2, "Pr(>|V|)"])
  } else {
    fit <- try(lm(max.traj ~ max.pos))
    if(class(fit)== "try-error"){
      nber <- numeric(0)
      fit <- lm(traj ~ seq_along(traj))
    }
    p.val <- try(coef(summary(fit))[2, "Pr(>|t|)"])
  }

  # p-values not return for regression performed on small vectors
  if(class(p.val) == "try-error") p.val <- 2
  
  return(list(coeff = fit$coefficients[2], p.val = p.val, nber.max = nber))
}
```

```{r fig.height = 21}
kwindow = 5
mini = 0
maxi = 1e6
robust = F

reg.max <- nad[, .(reg.slope = wrap_max_reg(value, kwindow, mini, maxi, robust)$coeff,
                   p.val = wrap_max_reg(value, kwindow, mini, maxi, robust)$p.val,
                   nber.max = wrap_max_reg(value, kwindow, mini, maxi, robust)$nber.max),
                   by = c("noise", "variable")]

ggplot(reg.max, aes(x=as.factor(noise),y=reg.slope)) + geom_boxplot(aes(fill=noise)) + theme(text = element_text(size = 45)) + ggtitle("Slopes")
ggplot(reg.max, aes(x=as.factor(noise),y=nber.max)) + geom_boxplot(aes(fill=noise)) + theme(text = element_text(size = 25)) + ggtitle("Number of maxima detected")
```

With robust fitting:

```{r warning=F, fig.height=21}
kwindow = 5
mini = 0
maxi = 1e6
robust = T

reg.max <- nad[, .(reg.slope = wrap_max_reg(value, kwindow, mini, maxi, robust)$coeff,
                   p.val = wrap_max_reg(value, kwindow, mini, maxi, robust)$p.val,
                   nber.max = wrap_max_reg(value, kwindow, mini, maxi, robust)$nber.max),
                   by = c("noise", "variable")]

ggplot(reg.max, aes(x=as.factor(noise),y=reg.slope)) + geom_boxplot(aes(fill=noise)) + theme(text = element_text(size = 45)) + ggtitle("Slopes")
ggplot(reg.max, aes(x=as.factor(noise),y=nber.max)) + geom_boxplot(aes(fill=noise)) + theme(text = element_text(size = 25)) + ggtitle("Number of maxima detected")
```

