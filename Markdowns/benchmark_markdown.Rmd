---
title: "Benchmarks - Cell synchrony"
author: "Jacques Marc-Antoine"
date: "2 ao√ªt 2017"
output:
  html_document:
    fig_width: 21
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```


## 1. Function definition (hidden in html)

```{r echo=FALSE}
dist_mean <- function(data, condition, tcol, measure, label, return.mean = F){
  # data: a data table containing trajectories and conditions
  # condition: column name that fully define an experimental condition, thus a set of trajectories analyzed together
  # tcol: time column name
  # measure: column name with quantity of interest
  # label: column name with label of individual objects in each condition (cell label)
  
  require(data.table)
  # 1) Get mean trajectory for each condition
  means <- data[, .(Average = mean(get(measure))), by = c(condition, tcol)]
  dat <- merge(data[, c(condition, label, tcol, measure), with = F], means, by = c(condition, tcol))
  
  # 2) Euclidean distance between each trajectory and the mean one
  distances <- dat[, .(sq_dist = (get(measure) - Average)^2) , by = c(condition, label)]
  euclid <- distances[, .(euclid_to_mean = sqrt(sum(sq_dist))), by = c(condition, label)]
  
  if(return.mean){
    return(list(means = means, euclid = euclid))
  } else {
    return(euclid)
  }
}


rollex <- function(x, k = 5){
  # Extended rolling mean, fill the extremeties with linear approximation
  require(zoo)
  roll <- rollmean(x, k, na.pad = T)
  NonNAindex <- which(!is.na(roll))
  fst <- min(NonNAindex)
  lst <- max(NonNAindex)
  
  # Left and Right slopes
  lslope <- (roll[fst + 1] - roll[fst]) / 2
  rslope <- (roll[lst] - roll[lst - 1]) / 2
  
  # Replace NAs generated by roll with approx
  for(i in 1:(fst-1)){
    roll[i] <- roll[fst] + lslope * (i - fst) 
  }
  for(i in (lst+1):length(roll)){
    roll[i] <- roll[lst] + rslope * (i - lst) 
  }
  return(roll)
}


clip <- function(x, y){
  # Take two numeric vectors of same length, set x to 1 when above y and x to 0 when below y
  return(ifelse(x >= y, 1, 0))
}


wrap_clip <- function(x, k = 5){
  return(clip(x, rollex(x, k)))
}


overlap <- function(x, y){
  # How often do 2 clipped time series have the same value?
  temp <- ifelse(x==y,1,0)
  return(sum(temp)/length(temp))
}


sim_phase_shifted <- function(n, noise, freq = 1, end = 100, return.wide = F){
  # A fucntion to simulate a population of n noisy sinusoidals that are phase shifted
  # n: number of sinusoids
  # freq: sampling rate (in time unit)
  # noise: standard deviation phaseshift
  # end: end time of simulations
  # return.wide: returns data in wide or long format
  
  require(data.table)
  # If sampling rate < 1, adjust end such that seq(from, to, by) re
  
  # Create a matrix of shifted times 
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  shifts <- rnorm(n, 0, noise)
  shifts <- matrix(shifts, nrow = length(tvec), ncol = n, byrow = T)
  time_matrix <- time_matrix + shifts

  # Replace each shifted time by it sine function
  sins <- sin(time_matrix)
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)  
  }
  
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


sim_phase_shifted_with_fixed_trend <- function(n, noise, slope, freq = 1, end = 100){
  # Add a trend, i.e. a linear increase or decrease, to simulations
  # See sim_phase_shifted for arguments. Slope indicates the slope of the trend (change of mean value per unit of time)
  
  sins <- sim_phase_shifted(n, noise, freq, end, return.wide = F)
  trend_vec <- unique(sins$Time)
  trend_vec <- trend_vec * slope
  sins[, value := value + trend_vec, by = .(variable)]
  return(sins)
}


sim_noisy_amplitude <- function(n, noise, freq = 1, end = 100, return.wide = F){
  # Create a matrix of times and noise
  tvec <- seq(0, end-1, by = freq)
  time_matrix <- matrix(tvec, nrow = length(tvec), ncol = n)
  noise_matrix <- replicate(n, rnorm(length(tvec), 0, noise))
  
  # Replace each shifted time by it sine function and add white noise
  sins <- sin(time_matrix)
  sins <- sins + noise_matrix
  
  # Go to data.table
  sins <- as.data.table(sins)
  sins <- cbind(seq(0, end-1, by = freq), sins)
  colnames(sins)[1] <- "Time"
  if(return.wide){
    return(sins)  
  }
  
  # Format long data table
  sins <- melt(sins, id.vars = "Time")
  return(sins)
}


multi_sims <- function(type, noises, ...){
  # /!\ not optimized, growing data table
  # Generate multiple simulations of the indicated type.
  # noises: numeric vector with noise value, DO NOT PASS 0, as it is already used to initialize the output
  # ps: phase shifted
  # pst: phase shifted with linear trend
  # na: noisy amplitude
  
  if(!(type %in% c("ps", "pst", "na"))){
    stop("type must be one of c('ps', 'pst', 'na')")
  }
  
  # Initialize data.table with no noise
  if(type == "ps"){multi_sim <- sim_phase_shifted(noise = 0, ...)}
  else if(type == "pst"){multi_sim <- sim_phase_shifted_with_fixed_trend(noise = 0, ...)}
  else if(type == "na"){multi_sim <- sim_noisy_amplitude(noise = 0, ...)}
  
  multi_sim$noise <- 0
  for(noise in noises){
    if(type == "ps"){temp <- sim_phase_shifted(noise = noise, ...)}
    else if(type == "pst"){temp <- sim_phase_shifted_with_fixed_trend(noise = noise, ...)}
    else if(type == "na"){temp <- sim_noisy_amplitude(noise = noise, ...)}
    temp$noise <- noise
    multi_sim <- rbind(multi_sim, temp)
  }
  return(multi_sim)
}


plot_sim <- function(data, x = "Time", y = "value", group = "variable", use.facet = T, facet = "noise", alpha = 0.2){
  require(ggplot2)
  p <- ggplot(data, aes_string(x = x, y = y)) + geom_line(aes_string(group = group), alpha = alpha)
  p <- p + stat_summary(fun.y=mean, geom="line", colour = "blue", size = 1.5)
  if(use.facet){
    p <- p + facet_grid(as.formula(paste(facet, "~ .")))
  }
  p
}


all_pairwise_stats <- function(data, condition, label, measure, k_roll_mean = 5){
  # Compute all pairwise measures: overlap_clipping and correlations (Pearson, Spearman, Kendall)
  # The clipping of trajectories is performed as first step
  
  # data: a data table containing CLIPPED trajectories
  # condition: column name that fully define an experimental condition; MUST BE INTEGERS, NUMERIC, FACTOR OR CHARACTERS
  # measure: column name with clipped trajectories
  # label: column name with label of individual objects in each condition (cell label); LABELS MUST BE INTEGERS, NUMERIC, FACTOR OR CHARACTERS
  
  if(!(class(data[,get(condition)]) %in% c("integer", "numeric", "character", "factor"))){
    stop("Column 'condition' must be integer, numeric, factor or character.")
  }
  if(!(class(data[,get(label)]) %in% c("integer", "numeric", "character", "factor"))){
    stop("Column 'label' must be integer, numeric, factor or character.")
  }
  
  require(data.table)
  setkeyv(data, c(condition, label))
  
  # Perform clipping
  ClipData <- data[, .(clip_measure = wrap_clip(get(measure), k = k_roll_mean)), by = c(condition, label)]
  setkeyv(ClipData, c(condition, label))
  
  # Number of rows for data table initialization, sum of number of pairs in each condition
  nber_row <- 0
  for(i in unique(data[, get(condition)])){
    nber_row <- nber_row + choose(length(unique(data[.(i), get(label)])), 2)
  }

  
  # One row = one pair in one condition; set column types according to input types
  out <- data.table(matrix(ncol = 7, nrow = nber_row))
  colnames(out) <- c(condition, "Label1", "Label2", "Overlap", "Pearson", "Spearman", "Kendall")
  if(class(data[,get(condition)]) == "integer"){out[[condition]] <- as.integer(out[[condition]])}
  else if(class(data[,get(condition)]) == "numeric"){out[[condition]] <- as.numeric(out[[condition]])}
  else if(class(data[,get(condition)]) == "character"){out[[condition]] <- as.character(out[[condition]])}
  else if(class(data[,get(condition)]) == "factor"){out[[condition]] <- as.factor(out[[condition]])}
  
  
  if(class(data[,get(label)]) == "integer"){
    out[, Label1 := as.integer(Label1)]
    out[, Label2 := as.integer(Label2)]
  }
  else if(class(data[,get(label)]) == "numeric"){
    out[, Label1 := as.numeric(Label1)]
    out[, Label2 := as.numeric(Label2)]
  }
  else if(class(data[,get(label)]) == "character"){
    out[, Label1 := as.character(Label1)]
    out[, Label2 := as.character(Label2)]
  }
  else if(class(data[,get(label)]) == "factor"){
    out[, Label1 := as.factor(Label1)]
    out[, Label2 := as.factor(Label2)]
  }
  
  
  out[, Overlap := as.numeric(Overlap)]
  out[, Pearson := as.numeric(Pearson)]
  out[, Spearman := as.numeric(Spearman)]
  out[, Kendall := as.numeric(Kendall)]
  
  curr_row <- 1L
  # Loop condition
  for(i in unique(data[, get(condition)])){
    labels <- unique(data[.(i), get(label)])
    # Loop 1st label
    for(j in 1:(length(labels)-1)){
      # Loop 2nd label
      for(k in (j+1):length(labels)){
        set(out, curr_row, 1L, i)
        set(out, curr_row, 2L, labels[j])
        set(out, curr_row, 3L, labels[k])
        # /!\ use clip data for overlap
        set(out, curr_row, 4L, overlap(ClipData[.(i, labels[j]), clip_measure], ClipData[.(i, labels[k]), clip_measure]))
        set(out, curr_row, 5L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="pearson"))
        set(out, curr_row, 6L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="spearman"))
        set(out, curr_row, 7L, cor(data[.(i, labels[j]), get(measure)], data[.(i, labels[k]), get(measure)], method ="kendall"))
        curr_row <- curr_row + 1L
      }
    }
  }
  return(out)
}
```



## 2. Data Simulation

```{r message=F, fig.height=21}
n <- 50 # number of trajectories per noise level
noises <- seq(0.2, 3, 0.2)
freq <- 1 # compute sinus every 1 time unit

# Phase shifted
ps <- multi_sims(type = "ps", noises = noises, n = n, freq = freq)
ps
# Phase shifted with trend
pst <- multi_sims(type = "pst", noises = noises, n = n, slope = 0.1, freq = freq)
# Amplitude noise
na <- multi_sims(type = "na", noises = noises, n = n, freq = freq)

plot_sim(ps)
plot_sim(pst)
plot_sim(na)
```

## 3. Distance to Mean

For each condition, this computes the distance between the average trajectory and each individual trajectory.

```{r}

cond <- "noise"
ti <- "Time"
mea <- "value"
lab <- "variable"

ps_mean <- dist_mean(data = ps, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
ps_mean
pst_mean <- dist_mean(data = pst, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
na_mean <- dist_mean(data = na, condition = cond, tcol = ti, measure = mea, label = lab, return.mean = F)
```

## 4. Pairwise Distances: Overlap clipping, Correlations Pearson, Spearman, Kendall

For each condition, take each pair of trajectories and compute the correlations between them (Pearson, Spearman and Kendall). In addition it clips the trajectories by comparison with their rolling means: whenever the trajectory is above its rolling mean, set it to 1 otherwise to 0. Finally for each pair of trajectories, the "overlap" metric, represents how often the trajectories of the pair have same value (i.e. 0.5 if complete random, 1 if they fully overlap).

This takes quite a while (partially) because it is implemented with for loops, but is still performed in reasonable time (i.e. a few minutes)

```{r message=F}
ps_pw <- all_pairwise_stats(data = ps, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
ps_pw
pst_pw <- all_pairwise_stats(data = pst, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
na_pw <- all_pairwise_stats(data = na, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
```


## 5. Plots of the distributions (code hidden in HTML)

#### Euclidean distance to the mean trajectory / !!! scale in y !!!

```{r message=F, echo=F, fig.height=10}
library(ggplot2)
library(gridExtra)

theme_update(plot.title = element_text(hjust = 0.5), text = element_text(size=15))

# Euclidean to Mean
p1 <- ggplot(ps_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted")
p2 <- ggplot(pst_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend")
p3 <- ggplot(na_mean, aes(x= noise, y = euclid_to_mean)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude")
grid.arrange(p1, p2, p3, ncol = 3)
```

#### Pairwise Overlap of clipped trajectories

```{r message=F, echo=F, fig.height=10}
# Overlap
q1 <- ggplot(ps_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(0,1))
q2 <- ggplot(pst_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(0,1))
q3 <- ggplot(na_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(0,1))
grid.arrange(q1, q2, q3, ncol = 3)
```


#### Pairwise Pearson correlations

```{r message=F, echo=F, fig.height=10}
r1 <- ggplot(ps_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
r2 <- ggplot(pst_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
r3 <- ggplot(na_pw, aes(x = noise, y = Pearson)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(r1, r2, r3, ncol = 3)
```

#### Pairwise Spearman correlations

```{r message=F, echo=F, fig.height=10}
s1 <- ggplot(ps_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
s2 <- ggplot(pst_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
s3 <- ggplot(na_pw, aes(x = noise, y = Spearman)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(s1, s2, s3, ncol = 3)
```

#### Pairwise Kendall correlations

```{r message=F, echo=F, fig.height=10}
t1 <- ggplot(ps_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted") + scale_y_continuous(limits = c(-1,1))
t2 <- ggplot(pst_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Phase Shifted with Trend") + scale_y_continuous(limits = c(-1,1))
t3 <- ggplot(na_pw, aes(x = noise, y = Kendall)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(-1,1))
grid.arrange(t1, t2, t3, ncol = 3)
```


## 6. Relations between the metrics

```{r}
cor(ps_pw[, 4:7])
cor(pst_pw[, 4:7])
cor(na_pw[, 4:7])
```


## 7. How to go from a distribution to a single value for each metrics

#### Distance to mean trajectory

For each condition, count the proportion of trajectories that are lying more than x standard deviation from the mean (conversion to z-score first?).


#### Correlations and Overlap

Get a p-value:
Assume that they are normally distributed, check that the distributions lies above 0 for correlations and above 0.5 for clipping (t-test).

```{r}
ps_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]

pst_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]

na_pw[noise !=0 , .(p.val.pears = t.test(Pearson)$p.value,
                    p.val.spear = t.test(Spearman)$p.value,
                    p.val.kenda = t.test(Kendall)$p.value,
                    p.val.ovrlp = t.test(Overlap, mu = 0.5)$p.value), by = noise]
```


## 8. Effect of window size in rolling mean for clipped trajectories


If we increase sampling rate, it means that there is more points per oscillation. Visually this means that the average trajectory is smoother. 

```{r}
plot_sim(sim_phase_shifted(n = 50, noise = 0.4, freq = 2), use.facet = F)
plot_sim(sim_phase_shifted(n = 50, noise = 0.4, freq = 0.2), use.facet = F)
```


The role of the rolling mean in clipping, is to "cut the oscillation in 2". A good case is like:

```{r}
# Contains 6 to 7 points per oscillation
sim <- sim_phase_shifted(n = 1, noise = 0, freq = 1)
plot(sim$Time, sim$value, type = "b")
lines(x=sim$Time, y=rollex(sim$value, k = 6), col = "red", lwd = 1.5)

# clip trajectory and scale for clarity on the plot
clip_traj <- wrap_clip(x = sim$value, k = 6)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x=sim$Time, y=clip_traj, col = "blue", type = "S")
```

It is a good case since the rolling mean (in red), cuts the trajectory (in black) at half-period (i.e. near to 0). This results in a clipped trajectory (in blue) that is up when the oscillation is "above 0" and down when its "below 0".

Now we multiply the sampling rate by 5, but keep the same window size for the moving average in the top case, and multiply it also by 5 in the bottom case:

```{r fig.height=15}
par(mfrow = c(2,1))
# Contains more than 35 points per oscillation
sim <- sim_phase_shifted(n = 1, noise = 0, freq = 0.2)

size_window <- 6
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")

size_window <- 35
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")
```

As we can see the moving average follows the signal perfectly with the small window, whereas it is out of phase with the larger window with much smaller amplitude. Clipping trajectory is ok in both cases. Nevertheless the top case is bad, why? Don't forget that we've been working with perfect sinusoid so far, let's see what happens with a tiny bit of noise in the amplitude of the signal:

```{r fig.height=15}
par(mfrow = c(2,1))
# Contains more than 35 points per oscillation
sim <- sim_noisy_amplitude(n = 1, noise = 0.1, freq = 0.2)

size_window <- 6
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")

size_window <- 35
plot(sim$Time, sim$value, type = "b")
lines(x = sim$Time, y = rollex(sim$value, k = size_window), col = "red", lwd = 1.5)
clip_traj <- wrap_clip(x = sim$value, k = size_window)
clip_traj <- ifelse(clip_traj == 0, -1, 1)
lines(x = sim$Time, y = clip_traj, col = "blue", type = "S")
```

As we observe, clipped trajectory becomes completely random with the small window, whereas it remains identical with the larger one. So we should choose the window size for the rolling mean such that it covers the number of points in an oscillation. 


On multiple simulations the distributions look like:

```{r}
# Already defined in section 4.
# na <- multi_sims(type = "na", noises = noises, n = n, freq = 1)
# na_pw <- all_pairwise_stats(data = na, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
# q3 <- ggplot(na_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Noisy Amplitude") + scale_y_continuous(limits = c(0,1))

na_high_freq <- multi_sims(type = "na", noises = noises, n = n, freq = 0.2)
na_high_freq_pw <- all_pairwise_stats(data = na_high_freq, condition = cond, label = lab, measure = mea, k_roll_mean = 5)
```

```{r fig.height = 10}
q3_high <- ggplot(na_high_freq_pw, aes(x = noise, y = Overlap)) + geom_boxplot(aes(group = noise)) + ggtitle("Window Size: 5; Freq: 0.2 (window too small)") + scale_y_continuous(limits = c(0,1))
grid.arrange(q3 + ggtitle("Window Size: 5; Freq: 1 (window of the right size)"), q3_high, ncol = 2)
```

